+++
date = "2017-04-04T15:15:49+09:00"
draft = true
title = "なぜ Go 言語にも goto が生き残ったか"
tags = ['go']
+++
ダイクストラ先生の"Go To Statement Considered Harmful"(goto文は有害である)
([PDF](http://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf)、
[テキストにしたもの](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html))
というキャッチーな見出しのエッセイが公開されたのは1968年の3月です。
しかしながら、それよりあと(1973年)に誕生した C 言語にも `goto` 文は残りました。
そしてまた、2009年に誕生した Go 言語にも。

なぜでしょうか？

以下のような有用な場面があるからです。

- 多重ループを抜ける
- エラー処理や終了処理を一箇所にまとめる
- 上の `found` の例にように、`goto` を使ったほうが簡潔になる

ただし「多重ループを抜ける」ことについてはラベル付き`break`を使えるので、

<!--more-->

# 「プログラミング言語C」における goto への言及

「プログラミング言語C」、俗に言うK&R本の3.8節(p.79)で `goto` が有用な場面について言及があります。
以下、長々と引用します。

> C には無限に悪用され得る `goto` および飛び先の名札も用意されている。形式としては，`goto` は決して不可欠のものではない。実際にも，それを使わないでプログラムを書くのは大抵の場合簡単である。本書では `goto` は使用していない。

> しかし，`goto` が有用である二，三の例をあげてみよう。最も一般的な使用は，例えば二つのループから一度に抜け出すときのように，深く入れ子(ネスト)になった構造での処理を中断させる場合である。`break` 文は最も内側のループを抜け出すだけなので直接使用することはできない。したがって

```
  for (...)
    for (...) {
      ...
      if (事故)
        goto error;
    }
  ...
error:
  騒ぎの始末をする
```

> この構造はエラー処理プログラムが複雑で，エラーがいくつかの箇所で起こり得るような場合に適している。

> もう一つの例として，二つの配列 a と b が共通の要素を持つかどうかを調べる問題を考えてみよう。一つの可能性は次のプログラムである。

```
  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
      if (a[i] == b[j])
        goto found;
  /* 共通の要素はなかった */
  ...
found:
  /* あった: a[i] == b[j] */
```

> gotoを使用するプログラムは、それを使わないで常に書くことができるが、たぶんテストの繰り返しや余分な変数という代償が付くであろう。例えば、上の配列探索は以下の次のようになる。

```
found = 0;
for (i = 0; i < n && !found; i++)
  for (j = 0; j < m && !found; j++)
    if (a[i] == b[j])
      found = 1;
if (found)
  /* あった: a[i] == b[j] */
  ...
else
  /* 共通の要素はなかった */
  ...
```

> ここにあげたような少数の例外を除くと、goto 文に頼るプログラムは、goto 文を使わないプログラムに比べて、一般によりわかりにくく、また保守しにくい。この問題についてわれわれは別に教条主義者ではないが、goto文はとにかく滅多なことでは使うべきでないと思う。

# Go言語処理系・標準ライブラリでの使われ方

[Go 言語処理系のソースコード](https://github.com/golang/go)を `grep` してみると、以下のようなパターンに大別されるように思います。
見つかった部分すべてを精読したわけではなくラベル名からの推測です。

- 終了処理・エラー処理を一箇所にまとめておいて飛ぶ
- 上の `found` の例のように、`goto` を使ったほうが変数・条件分岐が減る

[golangにgoto文が存在する理由](http://qiita.com/weloan/items/29018c8d0049abbe6199)で紹介されている通り、
例えば乱数を `0.0 <= x < 1.0` の範囲で生成するとして、ちょうど `1.0` を生成してしまったときだけ生成し直す、といった形のものもあります。
これも「`goto`を使ったほうが変数・条件分岐が減る」ケースの一例かと思います。
ただし 2017/04/01 の時点では乱数生成の部分からは `goto` が消えています(`1.0`が生成されないようアルゴリズムが変わった模様)。

[「有害なgoto」「時期尚早な最適化」、そしてプログラミングにまつわる神話は諸悪の根源である](http://postd.cc/programming-myths/)
[Gotoサンの話。結局のところ「goto禁止」はどういう話だったのか？](http://d.hatena.ne.jp/eel3/20150221/1424445453)
[goto不要論を本当に理解する](https://www.wizforest.com/diary/130220.html)

ダイクストラ先生は「ソースコードの構造と実行時の状態が乖離すればするほど難しくなる」

以下のようなループでは、行`X`に対応する実行時の状態

```go
for i:=0; i<10; i++ {
  X
}
```

[golangにgotoが存在する理由](http://qiita.com/weloan/items/29018c8d0049abbe6199)
[longjmpと例外](http://www.nurs.or.jp/~sug/soft/super/longjmp.htm#sec1)

[第５章　飛んでいきな](http://www7b.biglobe.ne.jp/~robe/cpphtml/html03/cpp03005.html)
