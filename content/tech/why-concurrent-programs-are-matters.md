+++
date = "2018-08-31T19:08:51+09:00"
draft = true
title = "なぜ並行プログラムが重要か"
tags = ["go","aws"]
+++

本記事は並行プログラムを書くことがいかに素晴らしいか、
ウハウハなのかということを啓蒙するものです。
また、並行プログラムのパターンについて理解することは、
クラウドサービスを利用したシステムを構築する上でも有用だということを主張したいと思います。

並行プログラムを書く目的は計算機資源を有効に活用することです。
昨今ではPCやスマートフォンを買ったらまず間違いなくマルチコアCPUなので、
マルチコアを活用できるプログラムを組むことは有意義だと言えそうです。

さて、我々はCPUがひとつしかない環境でも並行プログラムを書くべきでしょうか？
答えはイエスです。
なぜならコンピュータにはCPU以外にもディスクやネットワークケーブルなどの様々な部品があり、
ネットワークの向こうには別のCPUがあるため、
これらを「同時に」利用したほうが待ち時間が少なくてすむからです。

<!--more-->

# 並行プログラムを書くことのメリット

クラウドから計算リソースを借りるサービスのひとつである
[AWS Lambda](https://aws.amazon.com/jp/lambda/?nc2=h_m1)に以下のような記述があります。

> お支払いいただくのは、実際に使用したコンピューティング時間に対する料金のみです。

Lambda のような FaaS(Function as a Service) は大昔のCGIプログラムのようなもので、
APIリクエストなどのイベントが起きたときにプロセスを起動して処理を実行します。
そのため、イベントが発生しない期間においては計算リソースを借りる必要がなく、料金が発生しません。

夢のようなサービスですが、誤解を招きそうな部分もあります。

Lambda からデータベースへアクセスするケースを考えてみます。
何らかの理由(ネズミがLANケーブルをかじったなど)でデータベースの応答が遅かったらどうなるでしょうか？
タイムアウトまでの30秒の間、CPUはただぼんやりとしているだけで、意味のある処理を実行していません。
それでも支払いは必要です。

ですので、「実際に使用したコンピューティング時間」に課金されるというのはあまり良くない表現だと感じます。
クラウドのコンピューティングサービスはレンタルした時間——計算リソースを確保した時間——に応じて料金が発生するもので、
その間のCPU使用率が0%であっても支払いは避けられません。
レンタルしたビデオを見ずに返却してもお金が必要なのと同様です
(レンタルビデオという業種が減っているのでこれはあまりよくない例えかもしれません)。

昨今では、何かしらのシステムを構築しようと思ったら、
ほとんどすべての場合でクラウドベンダーのサービスなりどこかのプロダクトなりをネットワークごしに利用することになるため、
もし、レスポンスが返ってくるまでの空き時間に意味のある処理を実行しておくことができれば、
従量制課金による運用コストを減らすことができ、
あなたの評価は素晴らしいものになることでしょう。
(注：これは給与の上昇を保証するものではありません。
会社によっては上司とゴルフに行き、お世辞を言い、良い気分にさせることが有効なケースもあります)

# 並行と並列

「並行」と「並列」という言葉は日本語としての意味も似ているというか
筆者もその意味の違いを説明することが難しいです。
コンピュータサイエンスの分野では次のように英語と対応しています。

- 並行：Concurrent
- 並列：Parallel

ですが英辞郎では [concurrent](https://eow.alc.co.jp/search?q=concurrent) = 並列ですし、
 [parallel](https://eow.alc.co.jp/search?q=parallel) = 並行です。

言葉の定義には深入りしないほうが良いでしょう。
重要なのは「並行プログラム」というものを実現するためにはどんなものを実装すればよいのかという点です。

自分の好きな説明はGO言語の設計者の一人であるロブ・パイク氏の講演 [concurrency is not parallelism](https://talks.golang.org/2012/waza.slide#8)の以下の一文です。

> Concurrency is about structure, parallelism is about execution.

並行というのはプログラムの構造を指し、並列というのは実行の仕方を指します。
では並行プログラムというのはどんな構造なんでしょうか？
[このスライド](https://talks.golang.org/2012/waza.slide#6)の以下の一文が参考になります。

> Concurrency: Programming as the composition of independently executing processes.

独立して実行できる処理の組み合わせでプログラムを構成すること——自分の理解では、以下のようなプログラムがこれに当たります。

* I/O待ちなどで、ある処理が進められなくなった際に、プログラムの別の部分が実行できること
* 複数のデータを独立して——処理順序を決めなくとも実行できること

論理的には独立して実行できる処理があったとして、
それを逐次的なプログラムで記述することはもちろん可能です。
しかしそれを並列に実行することはできません。
(ただしプログラムの解析によって逐次的なプログラムから並列実行できる箇所を見つける、といったアプローチはありえます)

並行プログラムとは、独立に実行できる処理の部分を、逐次的ではなく、どのような順番で実行されても良いように記述したもの、ということになります。

# 並行プログラムの例

Go言語でのプログラム例を見てみます。
以下は、関数fの実行が完了してからgの実行を開始する、逐次プログラムです。

```
// 逐次プログラム
func main() {
  f()
  g()
}
```

以下のプログラムでは、`go f()`という行で関数fの実行を指示していますが、
fの完了を待たずにgの実行へ移るという意味となっています。
つまり、fとgのどちらが先に開始するか、完了するかが決まっていない並行プログラムです。

```
// 並行プログラム
func main() {
  go f()
  g()
}
```

二種類のプログラムの実行フローを図にしてみます。

<div>
<div style="display: inline-block; width:41%;">
<figure>
  <figcaption>逐次的プログラムの実行フロー</figcaption>
  <img width="100%" src="/img/why-concurrent-programs-are-matters/sequential.svg" />
</figure>
</div>

<div style="display: inline-block; width:50%;">
<figure>
  <figcaption>並行プログラムの実行フロー</figcaption>
  <img width="100%" src="/img/why-concurrent-programs-are-matters/concurrent.svg" />
</figure>
</div>
</div>

Go言語において並行プログラムを書く場合は、
`go`キーワードによってプログラマが独立した処理を明示しなければなりません。

# 並行プログラムのパターン

<!-- # プロセス、スレッド、goroutine -->

<!-- オペレーティングシステムというプログラムが登場するまで、 -->
<!-- コンピュータは同時に1つのプログラムしか実行できませんでした。 -->
<!-- つまり、勤務中にネットサーフィンをしつつ、上司に画面を覗かれそうになったらさっとエディタに切り替える、ということができなかったのです。 -->
<!-- ネットサーフィンならネットサーフィンに専念しなければなりませんでした(その当時はインターネットというものは存在しなかったですが)。 -->
<!-- そして、たまたま見つけたエロ画像をプリントアウトしている間には、ネットサーフィンは続けられなかったのです。 -->

# クラウドサービス(分散計算機環境)での並行処理パターン

以上の内容は単一の計算機上での話ですが、
同様の構造はクラウドサービスなどを利用して構築した複数の計算機(分散計算機環境)でも有効です。

たとえば、[キューベースの負荷平準化パターン](https://docs.microsoft.com/ja-jp/azure/architecture/patterns/queue-based-load-leveling)と呼ぶクラウドのアーキテクチャパターンがあります。
これは消費者がアクセスするリソース(RDBなど)が過負荷にならないよう、上限を制御することに主眼を置いた説明です。

AWSのクラウドデザインパターンでは[Queuing Chainパターン](http://aws.clouddesignpattern.org/index.php/CDP:Queuing_Chain%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)というものがあります。
あるデータに対して複数の処理を施すケースでは、処理内容によって負荷が異なります。
従って、スループットを一定にするためには処理内容に応じて消費者の数を変動する必要があります。

どちらのケースでも、キューに入れたデータの処理が「独立して行なえる」という点が重要です。

余談ですが AWS で最も古くから存在するサービスは SQS だそうです。
Amazon に来る注文をさばくデータベースへの負荷をコントロールするため Amazon 内部で使っていたのが SQS であり、
Amazon Web Service を開始する前から使っていた……という話を何かしらのイベントで耳にしました。

<!-- Producer-Consumer 問題というのがありました。 -->
<!-- これはProducerが無限にキューに追加するのを防ぐ、かつ生産者が空のキューを無限にポーリングし続けるのを防ぐためには -->
<!-- どう実装したら良いか、という問題です。 -->
<!-- クラウドサービスにおいては、生産者とキューと消費者の計算リソースが分かれていること、 -->
<!-- とりわけキューがマネージドサービスとして提供されており、 -->

# まとめ

- 並行プログラムにより計算機資源を効率良く扱える
- クラウドサービスを利用したシステムに、並行プログラムと同様のパターンが現れる
