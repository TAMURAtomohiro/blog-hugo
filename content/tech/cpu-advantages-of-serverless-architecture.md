+++
date = "2018-09-27T23:05:50+09:00"
draft = true
title = "料金面での Lambda と Fargate の比較"
tags = ["aws"]
+++

クラウドサービスといえばサーバレスです(要出典)。

サーバレスアーキテクチャの話を始めようとするとまず
「そもそもサーバレスアーキテクチャとは何ぞや？」
という話が立ちはだかるわけですが、本記事ではそこに触れません。

本記事では API サーバの計算リソースとしてコンテナとFaaSを比較したときに、
FaaSのほうがコスト面で有利かも、
と思ったことの個人的な考えを述べます。

結論としては
「FaaS なら N+1 冗長を考えなくてよいのでCPUを100%使えてコスト面で有利」
というものです。

<!--more-->

# 本記事で注目するサーバレスの特徴

「サーバレス」という言葉ででややこしいのは、
話によってはいわゆる「マネージドサービス」が含まれるケースがある点だと思います。
何しろマネージドサービスもサーバの管理をしなくてよいので。

日頃サーバの管理に奮闘している方の視点からすると、
そういった作業から解放される点に注目が集まるのも無理はないでしょう。

しかしながら、サーバの管理をしなくてよいことだけがサーバレスの特徴というわけではありません。
「サーバレスマニフェスト」(参考： [ServerlessConf Day1](https://yoshidashingo.hatenablog.com/entry/2016/05/27/201120))では以下のようなことも書かれています。

- アイドル時間に課金されない
- リクエスト単位のスケール
- 暗黙的な耐障害性

これを体現する典型的なものがFaaSです。
FaaSではAPIリクエストなどのイベントをきっかけに計算リソースを確保し、処理が終わったら解放するので、
イベントとイベントの間、アイドル時間には課金されません。
同時に複数のイベントが起きたとしても、それに応じて計算リソースを確保するため、スケールします。
AWS Lambda のデフォルト設定では、最大1000個まで同時に起動できます。
また、計算リソースとしてどの物理サーバを使うかが限定されておらず、
実行のたびに変わりうるので、耐障害性が確保される、ということになります。

# VM、コンテナなどにおける N+1 ルール (N+1冗長)

VMやコンテナを使った場合のAPIサーバの冗長化を考えましょう。
1台では落ちたら終わりなので最低2台は必要です。

では2台ともCPU負荷100%まで酷使するべきでしょうか？

2台ともCPU負荷100%の状態で1台がダウンしたときのことを想像してみましょう。
残った1台には200%分の負荷がかかります(退職した人の仕事が自分に回ってきたときと同じです)。
処理しきれないタスクが溜まり続けて、残った1台もダウンしてしまうでしょう。

冗長化のためには、1台がダウンしたとしても、残ったリソースの負荷が100%を超えないように余力を残す必要があります。
2台の場合には50%、3台の場合には66%、4台の場合には75%まで……というふうに負荷の上限が決まります。
負荷100%の状態から1台追加(N+1)して余力を残すことによって冗長性を確保するわけです。

これは、冗長性のためにCPUを100%使いきることができないということです。
クラウドサービスのオートスケール設定でも、「平均CPU負荷が80%を超えたら1台追加する」のようなルールになるため、
100%に近づけることはせず、設定した負荷以下で運用することになります。


# VM・コンテナとFaaSの料金面での比較

さて、VM、コンテナ、FaaS のような計算リソースの料金体系は、実はどれも時間単位の課金であります。
FaaSについては瞬間的な起動と解放、最低単位100ミリ秒などの要素により「イベントごとに課金されますよ」という点を前面に押し出してはいますが、
イベントにより起動したあとで sleep してまったくCPUを使わなかったとしても課金されるので、
使った分だけ課金という表現はちょっと語弊があり、実際のところはVM・コンテナと同様に、計算リソースを確保した時間に応じた課金なのです。

しかしながらFaaSは前項で述べたN+1ルールを考慮する必要がありません。
そのため常にCPU負荷100%でぶん回してよい、ということになります。

AWSのマネージドコンテナサービス [Fargateの料金](https://aws.amazon.com/jp/fargate/pricing/)を見ると
1 vcpu: $0.0632/h, 2GB メモリ: $0.0316/h で、合わせて $0.0948/h です。
一方[Lambdaの料金](https://aws.amazon.com/jp/lambda/pricing/)は 2GB メモリ: $0.120024/h です。

(注：Lambda は確保したメモリ量に応じて計算リソースが変化しますが、
2GB メモリのときに Fargate の 1 vcpu 相当の計算リソースが確保されるかどうかは明記されていないと思います。
また、リクエスト回数に応じた課金も発生します)

Fargate の料金 0.0948 / Lambda の料金 0.120024 ≒ 0.8 となるので、
時間当たりの料金としては Fargate のほうが安いように見えます。
しかしながらAPIサーバとしての用途であれば、
前項で述べたように冗長性のため100%使いきることができないため、
オートスケールでCPU負荷を80%付近に保つような設定だと、どっこいどっこいと言ったところです。

ソースコード(Lambda, Fargate 共通)

```
import json
import time

def fib(n):
    if n < 2:
        return n
    else:
        return fib(n-1) + fib(n-2)

def lambda_handler(event, context):
    start = time.time()
    print(fib(40))
    end = time.time()
    print(f"elapsed time: {end-start}")
    return None
```


1024MB
```
START RequestId: 42231d3d-c25b-11e8-96c7-ab61b7502c55 Version: $LATEST
102334155
elapsed time: 84.38983154296875
END RequestId: 42231d3d-c25b-11e8-96c7-ab61b7502c55
REPORT RequestId: 42231d3d-c25b-11e8-96c7-ab61b7502c55	Duration: 84406.61 ms	Billed Duration: 84500 ms 	Memory Size: 1024 MB	Max Memory Used: 21 MB
```

2048MB
```
START RequestId: 83967c8b-c25b-11e8-85c0-fb209a2070b1 Version: $LATEST
102334155
elapsed time: 51.387335538864136
END RequestId: 83967c8b-c25b-11e8-85c0-fb209a2070b1
REPORT RequestId: 83967c8b-c25b-11e8-85c0-fb209a2070b1	Duration: 51389.98 ms	Billed Duration: 51400 ms 	Memory Size: 2048 MB	Max Memory Used: 23 MB
```

3008MB
```
START RequestId: af28f7a9-c25b-11e8-b9f5-9ffe6d701621 Version: $LATEST
102334155
elapsed time: 51.57650899887085
END RequestId: af28f7a9-c25b-11e8-b9f5-9ffe6d701621
REPORT RequestId: af28f7a9-c25b-11e8-b9f5-9ffe6d701621	Duration: 51577.04 ms	Billed Duration: 51600 ms 	Memory Size: 3008 MB	Max Memory Used: 24 MB
```


Fargate
```
102334155
elapsed time: 40.42371892929077
```

何ということでしょう…… Fargate のほうが速いではありませんか。


# 余談

余談ですが Google Cloud Next'18 in Tokyo のどこかのセッションで
「サーバレスとは ssh ログインをしなくてよいこと」という表現を耳にしました。
これはこれで良い表現だと思います。


[Cloud Functions の料金](https://cloud.google.com/functions/?hl=ja)
$0.0000025	/ GB 秒
$0.0000100 / GHz 秒
