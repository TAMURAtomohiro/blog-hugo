+++
date = "2018-10-25T11:04:49+09:00"
draft = true
title = "べき等性: クラウドではどの行で失敗しても良いように作る"
tags = ["aws"]
+++

クラウド上で実行するコードは、物理的な故障の影響でどの行でも中断しうるので、
どこで止まっても再実行すれば何とかなるように設計しましょうという話です。
つまり AWS で言えばとりあえず SQS に入れて
各タスクを繰り返し実行しても問題ないようにする、というような方針です。

<!--more-->

あー今日は天気もいいしSQSからメッセージでも取得するかー、と
python で SQS からメッセージを取得するコードを書いていたときのことです。

すると以下のように取得時に例外が起こることを考慮して `catch` すると思います。

```
sqsResource = boto3.resource("sqs")
taskQueue = sqsResource.Queue(sqsEndpoint)
try:
  messages = taskQueue.receive_messages()
except Exception as e:
  # エラーログ出力

# messages の処理
...
# messages それぞれの削除
...
```
本当は「SQSが落ちることなんて、ある？」という気持ちで
エラー処理なんて無視したかったのですが、
実際のところ sqsEndpoint の指定が間違っていることでもエラーが起きるので、
エラーハンドリング自体は書いておいて損はないでしょう。

自分が問題だなと思ったのはこういった言語機構でのエラーハンドリングができない事態で、
上のコードが実行されている物理マシンがクラッシュしたときのことです。
これは例外ではダメだGo言語のスタイルのほうがいけてるぜ、
とかいう話ではなく、言語機構ではどうしようもない事態です。
また、上のコードを書いていたときの実行環境は AWS Lambda でしたが、
EC2 や Fargate、はてはクラウドサービスの計算リソースすべてに共通する問題です。

**物理マシンがクラッシュしたらどんなプログラム言語を使っていようとエラーログを出力できずに中断します。**

物理マシンがクラッシュする事態は稀だから考慮しなくてもいいでしょうか？
ことクラウドサービスにおいてはそれは逆だと思います。
クラウドベンダーとしては購入したハードウェアを寝る間も惜しんで酷使して
売上につなげたほうがいいわけですから、
とにかく稼働率を上げるために努力しているわけです。
これは稼働率が低いオンプレミス環境より壊れやすいということを意味します。
ゆりかごから墓場まで管理できるオンプレミスの環境と違い、
たまたま死にかけのマシンを引き当ててしまう可能性のあるクラウドサービスでは、
物理マシン故障のリスクは上がっていると思います。

自分の見解としては
**複数データセンターで冗長化されたマネージドサービスのダウンより、計算リソースが動いている物理マシンの故障をまず考慮すべき**
ということです。
自身の経験としても、ここ5年くらいで2回ほど、
1台で運用していた EC2 インスタンスにおいて、
物理的な故障によりアクセスできなくなるという事態を経験しました。
そしてこの物理マシンの故障による障害については特に補填もありません。
なぜなら物理マシンは壊れるのが当然であり、冗長化はユーザの責任だからです。

# SQS によるリトライ

SQSは取得したメッセージを明示的に削除する必要があります。
削除できなかった場合、可視性タイムアウト(Visibility Timeout)で指定された時間ののち、
再度キューから取得できる状態になります。
言い換えれば、明示的に削除できなかった場合には再度メッセージが取得できるためリトライを実現できます。

以下のような処理を考えましょう。
- SQSからメッセージを取得
- メッセージに基いてDBに書き込み
- メッセージに基いてS3にファイル保存
- SQSからメッセージ削除

この場合、DBやS3を更新することなりますので、
もし 「SQSからメッセージ削除」の時点で失敗した場合、DBやS3への影響は残っています。
