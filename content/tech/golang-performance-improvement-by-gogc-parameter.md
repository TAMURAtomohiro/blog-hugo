+++
date = "2017-04-07T11:38:45+09:00"
draft = true
title = "Go言語で GOGC を指定して実行時間を削減する"
tags = ['go']
+++

# 結論

前提としては、サーバなどの長期間稼動するプログラムでなく、ファイルを変換するようなプログラムでの話です。

短命なデータが多い場合は `GOGC` 環境変数を指定してヒープを多めに使うようにすると実行時間が減るかもしれません。
`GOGC` を大きくした場合、GC の間隔を広げる効果があり、GC の回数減および短命データへのマーク処理減が見込めます。

コマンドの例：

```
GOGC=400 ./main
```
<!--more-->

# 背景

TSV ファイルから JSON ファイルを生成するプログラムを書いたときの話です。
具体的な処理は以下のような感じで、

1. 参照用のデータファイルを読み込む
1. 処理対象の TSV ファイルを読み込み、何行分かをまとめ構造化して出力
1. 処理対象の TSV ファイルがなくなるまで繰り返し

構造化のため構造体を割り当てますが、出力すれば不要になるため、
短命なデータがめちゃくちゃ多いという処理でした。

試しに CPU profile の top10 を見てみるとやはり GC の処理で時間を食っているようでした。
たとえばマーク処理に関わる部分を抜き出してみると、

```
      flat  flat%   sum%        cum   cum%
      ...
    10.68s  7.35% 14.81%     11.84s  8.15%  runtime.greyobject
     9.64s  6.64% 21.44%      9.64s  6.64%  runtime.heapBitsForObject
      ...
     6.38s  4.39% 42.48%     27.81s 19.15%  runtime.scanobject
```

となって `18%` くらいありました。
短命データへのマーク処理が原因かと思われたため、
とりあえずヒープサイズを大きくして GC の間隔を広げれば改善できそうでしたが、
Go 言語ではヒープサイズを指定できないようで、`GOGC` という環境変数を用いて間接的にコントロールする形となりました。

# GOGC の意味

前回のGCで生き残ったデータの総容量を基準に、次の GC までの割り当て量を決めます。
デフォルトは `100` で、これは前回生き残ったデータ量と同じだけ割り当てが起こったら GC を起動する、という意味です。

今回のプログラムでは参照用のデータ(`100MB`程度)が生き続けるため、
少なくともこのサイズを基準としてヒープサイズを広げることができました。

# その他のアプローチ

ヒープサイズを広げる以外にも、

# 計測してから最適化する

「早すぎる最適化は諸悪の根源である」という Knuth 先生の言葉は誤解されることも多いようですが、
「直感的な推測はしばしば外れるから、計測に基いて最適化すべき部分を見極めてからやりなさい」という意味です。

---
参考：

- [Package runtime: Environment Variables](https://golang.org/pkg/runtime/)
- [GolangのGCを追う](http://deeeet.com/writing/2016/05/08/gogc-2016/)
- [「有害なgoto」「時期尚早な最適化」、そしてプログラミングにまつわる神話は諸悪の根源である](http://postd.cc/programming-myths/)
