+++
date = "2019-04-19T09:22:49+09:00"
draft = true
title = "Go言語におけるデータベースアクセスと漏れのある抽象化"
tags = ['go']
+++

前略：

寒暖の差が激しい日々が続き、
ようやく訪れた陽光うららかな日のことでした。
私にもGo言語からRDB(MySQL)へアクセスする機会がやってきたのです。

さて、
Go言語でリレーショナルデータベースにアクセスする際には、
最低限
標準ライブラリ[database/sql](https://golang.org/pkg/database/sql/)のようなデータベースにアクセスするためのインタフェースと、
実際にデータベースと通信するためのドライバ(MySQLの場合はたとえば[go-sql-driver/mysql](https://github.com/go-sql-driver/mysql))が必要です。

しかしながら世界中に100億人くらいユーザーがいるGo言語のことですから、
もっと便利なライブラリがあるのではと思いました。
いわゆる ORM です。
いくつものライブラリがあり、いくつもの記事がありました。
それらを調べる過程で、
データベースのレコードをGo言語の構造体にマッピングする100の方法のうち
どれがいいかを調べるより、
もっと考えなければならないことがあるのではないか、と思いました。

ストリーム処理です。

本記事は以下のことを目的としています。

- プログラムの違いにより データベースアクセス時のメモリ使用量がどう違ってくるかを示す
- 時には、抽象化された事柄の詳細に踏み入って調べることが重要ということを説く

<!--more-->

# 「漏れのある抽象化」とは何か

[Stack Overflow](https://stackoverflow.com/)を開発した Joel Spolsky 氏のブログ[JOEL ON SOFTWARE](https://www.joelonsoftware.com/)の
記事[The Law of Leaky Abstractions](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)に現れる言葉です。
昔は日本語の翻訳が[Joel on Software Translation Project](http://local.joelonsoftware.com/wiki/Main_Page)で読めたのですが、
書籍[Joel on Software](https://www.amazon.co.jp/Joel-Software-Spolsky/dp/4274066304)が出たためか、
記事がなくなりました。
(なぜか[間違ったコードは間違って見えるようにする](http://local.joelonsoftware.com/wiki/%E9%96%93%E9%81%95%E3%81%A3%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E9%96%93%E9%81%95%E3%81%A3%E3%81%A6%E8%A6%8B%E3%81%88%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B)は残っています)

ここで言う抽象化とは**「詳細を知らずともコードが書けること」**であり、
何かよく分からないことに出会ったらとりあえずGoogleで検索する僕らがいつも
オープンソースのライブラリを利用するときに恩恵に預かっていることです。
(オープンソースの隅々まで目を通し完全に理解してから使い始めたこと、
少なくとも自分には覚えがありませんし、
多くの人は使用しているプログラム言語の処理系の詳細について**何も**知らないでしょう)

抽象化は我々の生活を豊かにしてくれます。
抽象化はコードを書く時間を節約してくれるので、
業務中に空いた時間をウェブのくだらない記事を見て過ごすとか、
友達と飲み会の日時を調整するとかに使えます。

ところが、
時に我々は未曾有のトラブルに巻き込まれ、
**「詳細を知らなくてはならない」**事態に巻き込まれます。
Joel on Software より引用しますと、

> 自明でない抽象化にはすべて、程度の差こそあれ、漏れがある

ために、どうしても無垢な存在のままではいられず、泥くさい、
訳の分からない実装の詳細に踏み込む必要があるのです。

モダンなプログラム言語ではメモリ管理は自動化されているため、
自分の書いているプログラムがどのくらいのメモリを必要とするか見積もる必要はないですし、
オブジェクトを生成するコードを書いたとしても、
そこで実際にシステムへメモリを要求するかというとそうではなくて
事前に確保したメモリ領域に値を書くだけだったりしますし、
生成したオブジェクトの領域を明示的に解放するなんてコードは書きません。

メモリ管理は抽象化されているわけです。
そしてそれは16GBのメモリを積んだMacBookではうまく機能しますが、
GCPの無料利用枠である600MBのメモリしかないf1-microインスタンスでは失敗する、
といった事態を引き起こします。


# Go言語でのデータベースアクセスとメモリ使用量

実際に計測してみます。

まず Go 言語でメモリ使用量をざっくり表示する関数は以下のようになります。

```
var mem runtime.MemStats

func printMemory() {
	var mb uint64 = 1024 * 1024
	runtime.ReadMemStats(&mem)
	fmt.Printf("%v, %v, %v\n", mem.Alloc/mb, mem.TotalAlloc/mb, mem.Sys/mb)
}
```

ここで、`mem.Alloc` はその時点で必要なデータ量、
`mem.TotalAlloc` は累積で割り当てたデータ量、
`mem.Sys` はシステムから確保したメモリ量を意味します。
ここでは MB 単位にするため割っています。

[github.com/jmoiron/sqlx](https://github.com/jmoiron/sqlx)[^1] を使ってデータベースのテーブルから全データを読み込んでみます。
構造体 `Record` はテーブル定義に合わせてあります。
テーブルに3GB程度のデータが入っているものとします。

```
import (
  _ "github.com/go-sql-driver/mysql"
  "github.com/jmoiron/sqlx"
)

type Record struct {
  id int `db:"id"`
  // 省略
}

func main() {
  db, _ := sqlx.Open("mysql", "username:password@/dbname")
  records := []Record{}
  db.Select(&records, "select * from records")
  // 実際はここで 読み込んだデータに対する処理を行う

  printMemory()
}
```

`printMemory()` の出力結果は`3884, 4411, 4158`のようになります。
このプログラムでは、スライス `records` へ全データを保持するため、
テーブルサイズに比例して一度に必要なメモリサイズが増えることになります。

以下のように、1レコードずつ Scan する方法ではどうでしょうか？

```
func main() {
  var record Record
  db, _ := sqlx.Open("mysql", "username:password@/dbname")
  records, _ := db.Queryx("select * from openbd")

  for records.Next() {
    records.StructScan(&record) // エラーは無視
  }
  printMemory()
}
```

`printMemory()` の結果は `3, 3782, 69` です。
累積で割当てたデータ量はさほど変わりませんが、他は劇的に減少しています。
このプログラムでは、テーブルサイズに比例せず、一定量のメモリで動作します。

では、以下のように処理を別関数に切り分け、
さらに `printMemory()` の前に `runtime.GC()` というおまじないを書くとどうなるでしょうか？

```
func Batch() {
  db, _ := sqlx.Open("mysql", "username:password@/dbname")
  records := []Record{}
  db.Select(&records, "select * from records")
}

func main() {
  Batch()
  runtime.GC()
  printMemory()
}
```

`printMemory()` の結果 は `0, 4411, 4160` でした。
`Batch()`関数を抜けてしまうと、必要なデータ量はほぼゼロになっている、ということになります。
これは`Batch()`内の変数`records`が、関数を抜けたあとで参照できないために、
自動メモリ管理機能である「ガベージコレクション(Garbage Collection, GC)」の処理によって
`records`のために使用した領域が回収され再利用可能になったことによります。
しかしシステムから確保したメモリ量 `4160` はさほど変わっておらず、
`Batch()`の処理中に依然として大量のメモリを必要としていたことがうかがえます。

`runtime.GC()`関数呼び出しを明示的に追加したのは、
普段は GC も隠蔽され自動的に起こるものであり、そのタイミングを予測できないことから、
「必要データ量 ほぼゼロ」の状態を確実に作りたかったからです。


# 抽象化の下を覗く必要があるのか？

多くの場面では不要です。
そもそもメモリ管理が抽象化されてきたのは、
プログラムの目的がデータを処理するアルゴリズムによって価値のあるものを生み出すことにあり、
メモリやネットワーク機器のような、計算機のハードウェアをどのように制御するかといったことは気にしたくない、というニーズによるものです。

こういった抽象化を積み重ねてきたことで、
`http.Get` にURLを渡すだけで、なんやかんやあってウェブページの情報を取得できますし、
DBライブラリにユーザ名とパスワードのようないくつかの文字列を渡すだけでレコードを取得できるわけです。

しかしながら、
IoTデバイスのようなメモリの逼迫した環境や、
あるいはクラウドサービスの計算リソースのようなメモリ確保量に応じた料金体系によって、
抽象化から漏れてしまうどうしても詳細を知らなければならない機会というのは、
そんなに珍しいものでもないと思います。

というかまずクラウドサービスで計算リソースを


[^1]: sqlx は ORM ではなく、標準ライブラリ `database/sql` の拡張という位置付けを標榜しています
