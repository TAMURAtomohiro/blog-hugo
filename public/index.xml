<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>嵐の小舟より</title>
    <link>http://tamura.goga.co.jp/</link>
    <description>Recent content on 嵐の小舟より</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Mon, 30 Nov 2015 14:20:55 +0900</lastBuildDate>
    <atom:link href="http://tamura.goga.co.jp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>なぜ静的サイト配信が重要となるか</title>
      <link>http://tamura.goga.co.jp/whyStaticWebsiteGeneratorsAreTheNextBigThing/</link>
      <pubDate>Mon, 30 Nov 2015 14:20:55 +0900</pubDate>
      
      <guid>http://tamura.goga.co.jp/whyStaticWebsiteGeneratorsAreTheNextBigThing/</guid>
      <description>

&lt;p&gt;Smashing Magazine の
&lt;a href=&#34;http://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/&#34;&gt;Why Static Website Generators Are The Next Big Thing&lt;/a&gt;
という記事を読んでの、自分の理解のためのメモです。
直訳というわけでもなく、独自研究が含まれる恐れがあります。&lt;/p&gt;

&lt;h1 id=&#34;概要:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;概要&lt;/h1&gt;

&lt;p&gt;現在の CMS はサーバサイドで動的にHTMLを生成するアプローチが主流ですが、
ブラウザを取り巻く環境の変化や、CDN との兼ね合いで、
静的HTMLを配信してJavaScriptで書き換えるアプローチが重要になりそうです。&lt;/p&gt;

&lt;h1 id=&#34;サーバサイドで動的なhtml生成を行なうアプローチ:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;サーバサイドで動的なHTML生成を行なうアプローチ&lt;/h1&gt;

&lt;p&gt;ここで想定しているのは WordPress のようなCMSです。
コンテンツをデータベースに保存しておき、
リクエストに応じて PHP などのスクリプトで動的に HTML を生成します。
いわゆる LAMP スタックの構成となります。&lt;/p&gt;

&lt;h1 id=&#34;クライアントサイドで動的なhtml生成を行なうアプローチ:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;クライアントサイドで動的なHTML生成を行なうアプローチ&lt;/h1&gt;

&lt;p&gt;タイトルでは静的サイトジェネレータと言ってますが、静的サイトだけでなく、動的なコンテンツも対象です。
つまり、HTML と JavaScript コードを静的ファイルとしてユーザに配信したのち、
JavaScript コードによりコメントなどの動的なコンテンツを取得して表示を切り替えるという手法です。
いわゆる MEAN スタックのような構成で、データベースや API サーバを含むものも想定しています。&lt;/p&gt;

&lt;h1 id=&#34;サーバサイドでの動的な-html-生成の問題点:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;サーバサイドでの動的な HTML 生成の問題点&lt;/h1&gt;

&lt;h2 id=&#34;cdnと相性が悪い:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;CDNと相性が悪い&lt;/h2&gt;

&lt;p&gt;たとえばログインが必要なコンテンツでは、ユーザのログイン状態に応じてレスポンスが異なります。
また、コメント機能のついたサイトでは、誰かがコメントするたびに返却されるレスポンスが変わることになります。
このように、サーバサイド動的HTML生成では、
ある URL に対して返却されるレスポンスがデータベースや Cookie の状態などに依存するため、
CDN を利用しようと思うと、キャッシュの管理が非常に難しくなります。&lt;/p&gt;

&lt;p&gt;一方クライアントサイド動的HTML生成では、ある URL に対応するレスポンスは一意であり、
デプロイのタイミングで CDN のキャッシュを更新すればよいため、管理が容易です。&lt;/p&gt;

&lt;h2 id=&#34;遅い:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;遅い&lt;/h2&gt;

&lt;p&gt;結局のところサーバサイド動的HTML生成のアプローチで
どんなにパフォーマンスチューニングを施しても静的なHTML配信にはおよびません。
ただし、ここで重視しているのはファーストビューが表示されるまでの時間で、
すべてのコンテンツが読み込まれるまでの時間ではないことに注意してください。&lt;/p&gt;

&lt;p&gt;また、先に述べたようにサーバサイド動的HTML生成でのキャッシュ管理には難しい問題があり、
パフォーマンスチューニングには多大なコストがかかります。&lt;/p&gt;

&lt;p&gt;パフォーマンスの重要性については
&lt;a href=&#34;http://news.mynavi.jp/news/2012/12/11/025/&#34;&gt;ページが表示されるまでに3秒かかると57%のユーザが離脱する&lt;/a&gt;
(&lt;a href=&#34;http://blog.smartbear.com/web-performance/the-cost-of-poor-web-performance-infographic/&#34;&gt;元記事&lt;/a&gt;)
という調査に言及しています。
スマートフォンで貧弱なネットワークを介しての閲覧が増えているため、配信の速さは昔よりも重要です。&lt;/p&gt;

&lt;h1 id=&#34;歴史的経緯:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;歴史的経緯&lt;/h1&gt;

&lt;p&gt;WordPress が登場した当時は Ajax や DHTML が市民権を勝ち得ていませんでしたが、状況が変わりました。
データベースの情報に応じてコンテンツを生成するために、
従来はサーバサイドのスクリプトを利用する必要がありましたが、現在ではクライアントサイドで実現できます。&lt;/p&gt;

&lt;h1 id=&#34;静的サイトジェネレータ普及のために何が足りないか:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;静的サイトジェネレータ普及のために何が足りないか？&lt;/h1&gt;

&lt;p&gt;現在、静的サイトジェネレータと呼ばれるツールはざっくり言って
Markdown 形式で記述したコンテンツからHTMLを生成してGithubPagesで公開するためのものです(出力形式や公開先で違いはありますが)。
エンジニアが黒い画面を見つめて使うもので、
非エンジニアでもブラウザ上で使えるリッチなエディタや、
複数ユーザを管理するための認証機構などは含まれていません。
あるいは、好みのデザインを探せるマーケットプレイスのようなコミュニティも欲しいところです。&lt;/p&gt;

&lt;h1 id=&#34;静的html配信に向かないもの:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;静的HTML配信に向かないもの&lt;/h1&gt;

&lt;p&gt;大量のデータから検索とフィルタリングで生成されるコンテンツでは、
ユーザに配信してから処理するわけにもいかないので、
サーバサイドでの処理が必要になります。&lt;/p&gt;

&lt;p&gt;また、リアルタイム性が高く頻繁に更新されるようなコンテンツでも、
更新のたびに HTML を生成し直すことは現実的でないため、
静的HTMLでの配信ではなく API 経由でデータベースを参照するような形になるでしょう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ:b18f011c14223c1c8e900075a4dc18a6&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;静的サイトジェネレータというツール群にはまだ足りない部分がありますが、
静的サイト配信という手法は速度や CDN を利用したスケーラビリティの面で有利なので、
今後ますます重要になりそうです。&lt;/p&gt;

&lt;!--
未調査ですが[Dato](http://www.leanpanda.com/blog/2015/10/13/dato-cms-static-website/)というのもあります。
スケーラビリティは期間限定のキャンペーンサイトなどで必要になります。
--&gt;
</description>
    </item>
    
    <item>
      <title>Emacs から外部プロセスを呼び出して結果をエコーエリアに表示する</title>
      <link>http://tamura.goga.co.jp/callProcessOnEmacs/</link>
      <pubDate>Fri, 20 Nov 2015 13:00:29 +0900</pubDate>
      
      <guid>http://tamura.goga.co.jp/callProcessOnEmacs/</guid>
      <description>

&lt;p&gt;学生時代からの習慣と宗教上の理由から普段使いのエディタは Emacs
(ここでは &lt;a href=&#34;http://emacsformacosx.com/&#34;&gt;GNU Emacs for Mac OS X&lt;/a&gt;)
です。&lt;/p&gt;

&lt;p&gt;設定ファイルを除いて自分で Emacs Lisp を書いて機能を追加したことはこれまで無かったのですが、
このたび必要にかられて追加いたしました。&lt;/p&gt;

&lt;p&gt;ど素人なので作法やらベストプラクティスやらがわからないですが、まあ動きます。
&lt;a href=&#34;https://gist.github.com/TAMURAtomohiro/18cd0fb0ae33baa48625&#34;&gt;Gist&lt;/a&gt; にも置いてあります。&lt;/p&gt;

&lt;h1 id=&#34;経緯:be4749ace7856f2106f2c84e7a92ff65&#34;&gt;経緯&lt;/h1&gt;

&lt;p&gt;とあるプロジェクトで JavaScript のソフトウェアメトリクスを測り、
コード改善のときの目安とすることになりました。
そこで&lt;a href=&#34;http://es-analysis.github.io/plato/examples/marionette/index.html&#34;&gt;Plato&lt;/a&gt;を導入したわけですが、
このツールでは今まさに自分が変更したファイルのメトリクスを確認するのが面倒です。&lt;/p&gt;

&lt;p&gt;どうせなら書いたそばから教えていただければ「もうちょっとメトリクス上げてみようか」という気分にもなるわけです。
before-save-hook などで保存時に何かしらの処理をフックできることは知っていましたので、
前述の plato を呼んで結果を表示するくらいのことはすぐできるだろう……と作り始めました。&lt;/p&gt;

&lt;h1 id=&#34;メトリクスを取り出す:be4749ace7856f2106f2c84e7a92ff65&#34;&gt;メトリクスを取り出す&lt;/h1&gt;

&lt;p&gt;plato には「結果を標準出力に出す」ようなオプションがなかったため、
とりあえずごり押しで plato の結果を取り出してみます。
生成された HTML から Average Maintainability の部分を取り出せれば細かいことはとやかく言いません。
(一時ファイルの名前やらが決め打ちじゃ並列実行したときおかしくなるぞ、とか)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
TMPFILE=/tmp/js-metrics.js
REPORT_DIR=/tmp
cat - &amp;gt; ${TMPFILE}
plato -d ${REPORT_DIR} ${TMPFILE} &amp;gt; /dev/null
grep &#39;class=&amp;quot;stat&amp;quot;&#39; ${REPORT_DIR}/index.html | tail -n 1 | sed -e &amp;quot;s/&amp;lt;p class=\&amp;quot;stat\&amp;quot;&amp;gt;//g&amp;quot; | sed -e &amp;quot;s/&amp;lt;\/p&amp;gt;//g&amp;quot; | sed -e &amp;quot;s/ //g&amp;quot; | tr -d &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;現在のバッファの内容を外部プロセスに渡し-結果をエコーエリアに表示する:be4749ace7856f2106f2c84e7a92ff65&#34;&gt;現在のバッファの内容を外部プロセスに渡し、結果をエコーエリアに表示する&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;call-process-region&lt;/code&gt; という関数を使うと現在のバッファの内容を標準入力として外部プロセスに渡せるのでこれを使います。
ただ、エコーエリアに表示しようとして、結果の出力先バッファを &lt;code&gt;*Messages*&lt;/code&gt; とするやり方はうまくいかず(&lt;code&gt;*Messages*&lt;/code&gt;バッファが read-only になっていて書き込めない)、
&lt;code&gt;message&lt;/code&gt; 関数を使うことになりました。&lt;/p&gt;

&lt;p&gt;なので出力先バッファを用意しなきゃいけないですが、
自分で管理するのは面倒なので &lt;code&gt;with-temp-buffer&lt;/code&gt; を使ってみます。
これを使うと新たなバッファが作られ、一連の処理が終わったあとに破棄してくれます。
カレントバッファが切り替わってしまうので今回の目的のためには
元バッファの JavaScript コードを取得しておいて転記する必要があります。&lt;/p&gt;

&lt;p&gt;ということで今回の成果物を以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun jsmetrics ()
    (if (derived-mode-p &#39;js-mode) ; JavaScript ファイルが js-mode で開かれることを前提として JavaScript のみを対象とする
        (let ((jscode (buffer-string))) ; カレントバッファの内容を取得しておき
            (with-temp-buffer
                (insert jscode)         ; 一時バッファに書き込む
                (call-process-region (point-min) (point-max) &amp;quot;js-metrics.sh&amp;quot; t t nil) ; 一時バッファの内容を外部プロセスの結果で置き換える
                (message (buffer-string)))))) ; 結果をエコーエリアに表示

(add-hook &#39;js-mode-hook
    (lambda () (add-hook &#39;after-save-hook &#39;jsmetrics)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ:be4749ace7856f2106f2c84e7a92ff65&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;標準入出力という偉大なインタフェースのおかげで Emacs Lisp 内で完結させる必要がなく、
他言語のモジュールを利用できるのが素晴らしいです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静的サイトジェネレータの生成時間比較</title>
      <link>http://tamura.goga.co.jp/staticSiteGeneratorComparison/</link>
      <pubDate>Fri, 20 Nov 2015 11:35:26 +0900</pubDate>
      
      <guid>http://tamura.goga.co.jp/staticSiteGeneratorComparison/</guid>
      <description>

&lt;p&gt;エンジニア界隈ではどうもブログを作る目的で静的サイトジェネレータというものが使われている、
と聞いたため、せっかくなので使ってみることにしました。&lt;/p&gt;

&lt;p&gt;調べていく過程で&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;Hugo&lt;/a&gt;のサイトに
「Hugoは速いよ！」という内容の動画を見つけたり、
速度が原因で Hugo に移行したブログ記事を見かけたりして、
実行時間の伸び方が気になったのでざっくり確認してみます。&lt;/p&gt;

&lt;h1 id=&#34;対象としたジェネレータについて:a3f1f0d65ed4ea09eb7c2931fc64911b&#34;&gt;対象としたジェネレータについて&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.staticgen.com/&#34;&gt;StaticGen&lt;/a&gt;のスター数が多いものから選びました。
2015/11月の時点では Jekyll, GitBook, Octopress, Hexo, Hugo, Pelican の順です。&lt;/p&gt;

&lt;h1 id=&#34;測定環境:a3f1f0d65ed4ea09eb7c2931fc64911b&#34;&gt;測定環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;計算機&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mac OS X 10.10.5&lt;/td&gt;
&lt;td&gt;3.1 GHz デュアルコア Intel Core i7&lt;/td&gt;
&lt;td&gt;16GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;処理系のバージョン&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node.js&lt;/th&gt;
&lt;th&gt;Python&lt;/th&gt;
&lt;th&gt;Ruby&lt;/th&gt;
&lt;th&gt;Go&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5.0.0&lt;/td&gt;
&lt;td&gt;2.7.9&lt;/td&gt;
&lt;td&gt;2.2.1&lt;/td&gt;
&lt;td&gt;1.5.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;ジェネレータのバージョン&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Octopress&lt;/th&gt;
&lt;th&gt;Hexo&lt;/th&gt;
&lt;th&gt;Pelican&lt;/th&gt;
&lt;th&gt;GitBook&lt;/th&gt;
&lt;th&gt;Jekyll&lt;/th&gt;
&lt;th&gt;Hugo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3.0.11&lt;/td&gt;
&lt;td&gt;0.1.9&lt;/td&gt;
&lt;td&gt;3.6.3&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;td&gt;3.0.0&lt;/td&gt;
&lt;td&gt;v0.15-DEV&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;測定方法:a3f1f0d65ed4ea09eb7c2931fc64911b&#34;&gt;測定方法&lt;/h1&gt;

&lt;p&gt;以下の手順を繰り返し、5回計測して単純平均を取りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;出力先にある生成物を消しておく&lt;/li&gt;
&lt;li&gt;本文に&amp;rdquo;あ&amp;rdquo;を1000文字並べた md ファイルを必要な個数用意する

&lt;ul&gt;
&lt;li&gt;1,10,100,1000 という刻み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;各ジェネレータの実行時間を time コマンドの user + sys で測る

&lt;ul&gt;
&lt;li&gt;たとえば Hexo なら hexo generate を実行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;生成時間測定結果:a3f1f0d65ed4ea09eb7c2931fc64911b&#34;&gt;生成時間測定結果&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;静的サイトジェネレータの CPU 時間(秒)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;記事数&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Octopress&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Hexo&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Pelican&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Gitbook&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Jekyll&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Hugo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.39&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.43&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.02&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.98&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.96&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.44&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.37&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.03&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.94&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.79&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.55&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;25.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.61&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.34&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.82&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&#34;http://tamura.goga.co.jp/img/staticSiteGeneratorComparison.png&#34; alt=&#34;静的サイトジェネレータの実行時間グラフ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;確かに Hugo が速いです。
CPU 時間も短いですが、Hugo はどこかで並列処理をしているらしくマルチコアを活用できているようだったため、
実時間ではもう少し速くなるはずです。&lt;/p&gt;

&lt;h1 id=&#34;そもそも生成時間が長いと何が困るのか:a3f1f0d65ed4ea09eb7c2931fc64911b&#34;&gt;そもそも生成時間が長いと何が困るのか？&lt;/h1&gt;

&lt;p&gt;編集→確認のループが長くなりイライラします。
記事を保存してから LiveReload で再読み込みが完了するまでの待ち時間が苦痛になりますし、
デザインを変えようとして再生成するとか、Github Pages などへのデプロイのために再生成するとか、
CPUを温めるために再生成するとか、生活の端々でいったん待たされることになります。&lt;/p&gt;

&lt;p&gt;「Hugo に移行した」系のブログ記事でも
「元々使っていたジェネレータの遅さに耐えきれなくなった」という理由が散見されました。
生成時間の長さは移行の原因となりえます。&lt;/p&gt;

&lt;p&gt;というわけで生成時間の伸び方は静的サイトジェネレータを選ぶ際のひとつの尺度になるかと思います。&lt;/p&gt;

&lt;p&gt;とはいえ記事数が少ないうちは問題にならないですし、
生成物の違い・Github Pages などとの連携のような機能面での差異、
デザインの豊富さや情報の多さなども重要ですから、問題になってから移行を考えてもいいと思います。
そもそも別のことをやって待てばいいという向きもあるでしょうし、
耐えきれるかどうか、一度適当に記事を増やして体感してみるのがおすすめです。&lt;/p&gt;

&lt;p&gt;とりあえず自分は Hugo を使ってみます。&lt;/p&gt;

&lt;h1 id=&#34;余談:a3f1f0d65ed4ea09eb7c2931fc64911b&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;Octopress の時間は指数的に増えているように見えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tamura.goga.co.jp/img/staticSiteGeneratorComparison-5000.png&#34; alt=&#34;静的サイトジェネレータの実行時間グラフ&#34; /&gt;&lt;/p&gt;

&lt;!-- 10000 記事では Hugo のサーバが起動しませんでした。 --&gt;

&lt;!-- ``` --&gt;

&lt;!-- ERROR: 2015/11/16 Error: listen tcp 127.0.0.1:1313: socket: too many open files in system --&gt;

&lt;!-- ``` --&gt;
</description>
    </item>
    
  </channel>
</rss>