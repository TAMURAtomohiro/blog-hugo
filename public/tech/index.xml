<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Teches on 嵐の小舟より</title>
    <link>https://tmrtmhr.info/tech/index.xml</link>
    <description>Recent content in Teches on 嵐の小舟より</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sun, 16 Apr 2017 15:01:48 +0900</lastBuildDate>
    <atom:link href="https://tmrtmhr.info/tech/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go言語の json.Unmarshal で読み込んだデータをテストするときは数値の型に注意する</title>
      <link>https://tmrtmhr.info/tech/golang-unmarshal-to-nil-interface/</link>
      <pubDate>Sun, 16 Apr 2017 15:01:48 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/golang-unmarshal-to-nil-interface/</guid>
      <description>&lt;p&gt;以下のようなコードで &lt;code&gt;interface{}&lt;/code&gt; に対し数値を読み込んだ際、
数値の型は &lt;code&gt;float64&lt;/code&gt; になります。
(参考: &lt;a href=&#34;https://golang.org/pkg/encoding/json/#Unmarshal&#34;&gt;公式ドキュメント&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var got []interface{}
json.Unmarshal([]byte(&amp;quot;[1,2,null]&amp;quot;, &amp;amp;got)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、これをテストするために比較対象のデータをリテラルとして用意すると、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;want := []interface{}{1,2,nil}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定数のデフォルト型の宿命で数値の型が &lt;code&gt;int&lt;/code&gt; になってしまうため、&lt;code&gt;reflect.DeepEqual&lt;/code&gt; などの比較において失敗してしまいます。&lt;/p&gt;

&lt;h1 id=&#34;解決策&#34;&gt;解決策&lt;/h1&gt;

&lt;p&gt;解決策としては以下の2つかな、と考えており、(2)のほうは煩雑なので今のところ(1)でやっています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;テストデータも &lt;code&gt;json.Unmarshal&lt;/code&gt; で作る&lt;/li&gt;
&lt;li&gt;明示的に &lt;code&gt;float64(1)&lt;/code&gt; として変換する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;コードの挙動確認&#34;&gt;コードの挙動確認&lt;/h1&gt;

&lt;p&gt;以下でコードの挙動を確認できます。
&lt;a href=&#34;https://play.golang.org/p/7U2AtxLORC&#34;&gt;The Go Playground&lt;/a&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/tmrtmhr/197cf8ed967cc97c0388464b315cfda0.js&#34;&gt;&lt;/script&gt;</description>
    </item>
    
    <item>
      <title>JavaScript でプリミティブ値のプロパティを参照すると対応するオブジェクトが一時的に作られる</title>
      <link>https://tmrtmhr.info/tech/javascript-property-of-primitive-value/</link>
      <pubDate>Sat, 15 Apr 2017 22:46:29 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/javascript-property-of-primitive-value/</guid>
      <description>&lt;p&gt;JavaScript では以下のように数値のプロパティを参照することはできません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;0.foo
// 構文エラー
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;変数に入れると構文上は正しいため参照できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 0;
console.log(x.foo);
// =&amp;gt; undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あるいは文字列の &lt;code&gt;length&lt;/code&gt; プロパティを参照することも。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;quot;bar&amp;quot;.length
// =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかしながらプリミティブ値はオブジェクトではないため、プロパティもプロトタイプチェーンもありません。
ではプリミティブ値のプロパティにアクセスしようとしたときに何が起こるかというと、
&lt;code&gt;Number&lt;/code&gt; などの対応するオブジェクトが生成されます。&lt;/p&gt;

&lt;p&gt;本記事は、この挙動が言語仕様のどの部分で言及されているのかのメモです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;プリミティブ値のプロパティ参照をするときの挙動&#34;&gt;プリミティブ値のプロパティ参照をするときの挙動&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-getvalue&#34;&gt;ECMAScript 2015言語仕様 6.2.3.1節 GetValue(V)&lt;/a&gt;
の以下の部分です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If HasPrimitiveBase(V) is true, then&lt;/p&gt;

&lt;p&gt;Assert: In this case, base will never be null or undefined.&lt;/p&gt;

&lt;p&gt;Let base be ToObject(base).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ということで言語仕様としてプリミティブ値のプロパティ参照はエラーじゃないと分かり安心しました。
夜もぐっすり眠れそうです(納期が近くなければ)。&lt;/p&gt;

&lt;p&gt;ただし、ここで生成されたオブジェクトはその場限りのものなので、
&lt;strong&gt;プリミティブ値がオブジェクトのように扱えるわけではない&lt;/strong&gt;ことには注意が必要です。
具体的には以下のように数値のプロパティに対して代入をしたとしても、
その結果が残りません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 0;
x.foo = 1;
console.log(x.foo);
// =&amp;gt; undefined
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>AWS Lambda (Node.js v6.10) から DynamoDB に入れた Gzip バイナリデータを展開する</title>
      <link>https://tmrtmhr.info/tech/aws/using-binary-data-in-dynamodb/</link>
      <pubDate>Tue, 11 Apr 2017 21:37:09 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/aws/using-binary-data-in-dynamodb/</guid>
      <description>&lt;p&gt;AWS DynamoDB では指定した IO 性能に応じて料金が発生するため、
クエリなどで使用しないプロパティについては gzip 圧縮などを施してバイナリデータとして格納したほうが、
必要な IO 性能が少なくなるためお得です(参考：&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/amazondynamodb/latest/developerguide/GuidelinesForItems.html#GuidelinesForItems.CompressingLargeAttributeValues&#34;&gt;大量の属性値を圧縮する&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;本記事は、AWS Lambda (Node.js 6.10) から DynamoDB のデータを取得し、
展開する処理のメモです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;DynamoDB に以下のような形式でデータが入っているとします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &amp;quot;hash_id&amp;quot;: &amp;quot;string&amp;quot;,
  &amp;quot;body&amp;quot;: JSON データ文字列を gzip 圧縮したバイナリ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでは &lt;code&gt;hash_id&lt;/code&gt; を partition key として指定しています。
なので以下のように &lt;code&gt;hash_id&lt;/code&gt; を指定して GET するとデータが取得できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dynamodb = new AWS.DynamoDB.DocumentClient();
var params = { TableName: &#39;dynamedb_table_name&#39;, Key: { &#39;hash_id&#39;: &#39;xxx&#39; } };
dynamodb.get(params, function(err, data) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSON 形式ではバイナリデータを扱えないので、Base64 形式に直してやりとりします。
しかし、受信した段階で &lt;code&gt;data.Item.body&lt;/code&gt; は &lt;code&gt;Buffer&lt;/code&gt; データとなっているようです。
(参考：&lt;a href=&#34;http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#get-property&#34;&gt;AWS SDK for Javascript のドキュメント&lt;/a&gt;)&lt;/p&gt;

&lt;!--
そのため、DynamoDB からのレスポンスである `data.Item.body` は「Base64 エンコードされたバイナリデータのバイト列(`Buffer`)」という状態です。

なのでこれをデコードしたバイト列を作り、

```
var binary = Buffer.from(data.Item.body.toString(), &#39;base64&#39;);
```
--&gt;

&lt;p&gt;なのでこれを展開します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var body = zlib.gunzipSync(data.Item.body);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これも &lt;code&gt;Buffer&lt;/code&gt; なので、文字列に変換して parse することでようやく元の JSON データとなります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JSON.parse(body.toString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に以上の処理を行う AWS Lambda のサンプルを置いておきます。
&lt;script src=&#34;//gist.github.com/tmrtmhr/3b8b9630ad01a5768c4a8b93ae6a814c.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Protractor での E2E テスト時に Google Chrome の通知バーを消す</title>
      <link>https://tmrtmhr.info/tech/chrome-disable-infobars/</link>
      <pubDate>Thu, 06 Apr 2017 19:44:06 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/chrome-disable-infobars/</guid>
      <description>&lt;h1 id=&#34;結論&#34;&gt;結論&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Google Chrome の起動オプションに &lt;code&gt;--disable-infobars&lt;/code&gt; を渡す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;経緯&#34;&gt;経緯&lt;/h1&gt;

&lt;p&gt;バージョン 57.0.2987.133(64-bit) あたりの Google Chrome と
Selenium Chrome driver 2.28 でE2Eテストを実行すると
&amp;ldquo;Chrome is being controlled by automated test software&amp;rdquo; とか
&amp;ldquo;Chrome は自動テスト ソフトウェアによって制御されています&amp;rdquo; とかいう黄色い通知バーが出てくるようになりました。&lt;/p&gt;

&lt;p&gt;まあ画面キャプチャには入らないですし、出てくること自体はいいんですけれども、
そのせいで失敗する E2E テストが出てきて、おいおい誰だよこんなコード書いたの、やろう、ぶっころしてやる、
と込み上げてくる怒りを糧に調べた解決法をこの記事へ記す次第です。&lt;/p&gt;

&lt;p&gt;結局 Google Chrome の起動オプションに &lt;code&gt;--disable-infobars&lt;/code&gt; を渡して表示しないようにしました。&lt;/p&gt;

&lt;p&gt;protorator を仕様する場合は設定ファイルに以下のような内容があれば OK です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;capabilities: [
  chromeOptions: {
    args: [&#39;disable-infobars&#39;],
  },
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;mac-で-google-chrome-に-自動テストが云々-の通知バーを出す方法&#34;&gt;Mac で Google Chrome に&amp;rdquo;自動テストが云々&amp;rdquo;の通知バーを出す方法&lt;/h1&gt;

&lt;p&gt;ターミナルで以下のように打つと起動している Chrome すべてに通知バーが出てきて嫌な気持ちになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --enable-automation
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;通知バーが出ているときの-window-の高さ&#34;&gt;通知バーが出ているときの window の高さ&lt;/h1&gt;

&lt;p&gt;以下のコードで高さを見てみると、通知バーの有無で 40px 違っていました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.element(window).height()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;e2e-テスト失敗の原因&#34;&gt;E2E テスト失敗の原因&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;E2Eテストのコードがウィンドウの高さに強く依存していた(スクロール量がピクセル値でハードコーディングされている、など)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sqa.stackexchange.com/questions/26051/chrome-driver-2-28-chrome-is-being-controlled-by-automated-test-software-notif&#34;&gt;Chrome driver 2.28 “Chrome is being controlled by automated test software” notification .Can it be removed?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>HTML要素をドラッグアンドドロップ(D&amp;D)中にブラウザ外に出た場合、D&amp;Dを終了するよう RxJS 5 を用いて実装する</title>
      <link>https://tmrtmhr.info/tech/drag-and-drop-using-rxjs/</link>
      <pubDate>Tue, 04 Apr 2017 17:24:23 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/drag-and-drop-using-rxjs/</guid>
      <description>&lt;p&gt;HTML要素をドラッグアンドドロップ(以降 D&amp;amp;D)で移動させようと思ったときは、
対象要素に対する &lt;code&gt;mousedown&lt;/code&gt;、&lt;code&gt;mousemove&lt;/code&gt;、&lt;code&gt;mouseup&lt;/code&gt; のイベントを使って実装するかと思います。&lt;/p&gt;

&lt;p&gt;しかしながらウィンドウ外では対象要素の &lt;code&gt;mouseup&lt;/code&gt; を捕捉できないため、
単純な実装ではウィンドウ外でD&amp;amp;Dをやめて戻った際、再度クリックなどして&lt;code&gt;mouseup&lt;/code&gt;が発生するまで要素が追従してしまいます。&lt;/p&gt;

&lt;p&gt;本記事では以下の挙動を &lt;a href=&#34;https://github.com/ReactiveX/rxjs&#34;&gt;RxJS&lt;/a&gt; で実装してみた例です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;D&amp;amp;D 終了時は初期位置に移動する&lt;/li&gt;
&lt;li&gt;ウィンドウ外で D&amp;amp;D 終了(&lt;code&gt;mouseup&lt;/code&gt;)を検知する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;とりあえず触ってみてください。Google Chrome 57.0.2987.133 (64-bit) でしか動作確認してません。&lt;/p&gt;

&lt;script src=&#34;https://code.jquery.com/jquery-3.2.0.min.js&#34;
  integrity=&#34;sha256-JAW99MJVpJBGcbzEuXk4Az05s/XyDdBomFqNlM3ic+I=&#34;
  crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;https://unpkg.com/rxjs/bundles/Rx.min.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;https://tmrtmhr.info/js/drag-and-drop.js&#34;&gt;&lt;/script&gt;

&lt;div id=&#34;dnd-container&#34; style=&#34;position: relative; width: 512px; height:64px;&#34;&gt;
&lt;div id=&#34;dnd-target&#34; class=&#34;z-depth-2&#34; style=&#34;width:32px; height: 32px; background-color: blue; position:absolute; top: 16px; left: 240px; z-index: 999;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;https://liginc.co.jp/web/js/151272&#34;&gt;「RxJS」初心者入門 – JavaScriptの非同期処理の常識を変えるライブラリ&lt;/a&gt;
にあるコードとほぼ同じですが、終了条件のストリームを &lt;code&gt;mouseup&lt;/code&gt; だけでなく &lt;code&gt;$(window)&lt;/code&gt; の &lt;code&gt;mouseup&lt;/code&gt; からも作っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  // 終了条件を表すストリーム
  var terminateDndStream = Rx.Observable.merge(
    mouseUpStream,
    Rx.Observable.fromEvent($(window), &#39;mouseup&#39;)
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回用いた技術的なポイントは以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;window&lt;/code&gt; 内でドラッグを開始した場合、ウィンドウ外での &lt;code&gt;mouseup&lt;/code&gt; や &lt;code&gt;mousemove&lt;/code&gt; を捕捉できる&lt;/li&gt;
&lt;li&gt;イベントストリームをマージして OR 条件を表現する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/web/js/151272&#34;&gt;「RxJS」初心者入門 – JavaScriptの非同期処理の常識を変えるライブラリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/tyfkda/items/228934160b0951a8e732&#34;&gt;マウスをウィンドウ外で離されてもイベントを受け取る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/14912515/how-to-detect-a-mouseup-event-outside-the-window&#34;&gt;How to detect a MouseUp event outside the window?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Gist も貼っておきます。
&lt;script src=&#34;//gist.github.com/tmrtmhr/d02aaa74e54a6fa684137ae8d4d8b16e.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go言語でアプリケーション・ハンガリアン記法的なことを型で表現する</title>
      <link>https://tmrtmhr.info/tech/golang-hungarian-notation/</link>
      <pubDate>Mon, 03 Apr 2017 17:35:08 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/golang-hungarian-notation/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://local.joelonsoftware.com/wiki/%E9%96%93%E9%81%95%E3%81%A3%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E9%96%93%E9%81%95%E3%81%A3%E3%81%A6%E8%A6%8B%E3%81%88%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B&#34;&gt;間違ったコードは間違って見えるようにする&lt;/a&gt;
で説明されている「アプリケーションハンガリアン記法」とは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同じデータ型の変数を区別するために、内容を示す名前をつける&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というものです。
先のページで挙げられている例では、行と列の最大値に &lt;code&gt;rowMax&lt;/code&gt; &lt;code&gt;colMax&lt;/code&gt; と名前をつけることで取り違えを防ぐ、といった感じです。
これらはともに整数なので相互に代入できてしまいますが、バグなので、命名規則で気づきやすくする、という意図です。&lt;/p&gt;

&lt;p&gt;Go 言語では型に別名をつけることができ、コンパイル時の型チェックで違う型として扱われるため、取り違えを防ぐのに有効です。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;例えば緯度・経度などはともに実数ですが、それぞれ別の型名を与えておくと型チェックを利用できてうれしいです。&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/tmrtmhr/ae1025314c09b102d43189e6232a1cd7.js&#34;&gt;&lt;/script&gt;</description>
    </item>
    
    <item>
      <title>なぜGo言語はエラー返却に例外機構を使わないのか</title>
      <link>https://tmrtmhr.info/tech/why-does-golang-not-have-exceptions/</link>
      <pubDate>Mon, 03 Apr 2017 17:04:30 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/why-does-golang-not-have-exceptions/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://golang.jp/go_faq#exceptions&#34;&gt;Go言語 FAQ&lt;/a&gt;より引用すると&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;例外(exception)がない理由は?&lt;/p&gt;

&lt;p&gt;我々は、処理構造を制御するためのtry-catch-finally形式の例外処理機構によって、コードが入り組んでしまうと考えています。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とのことです。&lt;/p&gt;

&lt;p&gt;うーん、これだけじゃよく分かりません。&lt;/p&gt;

&lt;p&gt;知りたいのは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「例外機構が有用な場面」についてGo言語ではどのように対処するのか？
はたしてGo言語の他の機能を組み合わせることでカバーできるのか？&lt;/li&gt;
&lt;li&gt;「例外機構ではコードが入り組んでしまう」というのはどういうことを指しているのか？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自分の探し方が悪かったら申し訳ないですが、
講演やら Effective Go やらでこういったことに言及している部分を見つけられなかったので、
調べた内容と自分の推測をまとめてみます。&lt;/p&gt;

&lt;p&gt;結論としては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;例外機構が欲しい場面は Go 言語の他の機能でカバーできそう&lt;/li&gt;
&lt;li&gt;例外機構によるエラー返却では、関数の出口が増えるため制御フローが複雑になる&lt;/li&gt;
&lt;li&gt;エラー値返却の手段としての例外機構は、並行プログラムにそぐわない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということです。&lt;/p&gt;

&lt;p&gt;Go言語の他の機能というのは多値返却、&lt;code&gt;goto&lt;/code&gt;、&lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;panic&lt;/code&gt;、&lt;code&gt;recover&lt;/code&gt; です。
具体的にエラーハンドリングのコードがどうなるかについては別の記事にまとめたいです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;例外機構にいたった歴史&#34;&gt;例外機構にいたった歴史&lt;/h1&gt;

&lt;p&gt;まず例外機構というのが何を目的に生まれたのかおさらいしてみました。&lt;/p&gt;

&lt;p&gt;たまたま手元にあった「Concepts in Programming Languages(CIPL)」によると例外機構については「8章 Control in Sequential Languages」の中にあります。
つまり例外機構とは制御フローを記述するものです。&lt;/p&gt;

&lt;h2 id=&#34;行番号ベースのジャンプ-例-fortran&#34;&gt;行番号ベースのジャンプ(例：Fortran)&lt;/h2&gt;

&lt;p&gt;以下、CIPL p.204-205 から引用したコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10 IF (X .GT. 0.000001) GO TO 20
   X = -X
11 Y = X*X - SIN(Y)/(X+1)
   IF (X .LT. 0.000001) GO TO 50
20 IF (X*Y .LT. 0.00001) GO TO 30
   X = X - Y -Y
30 X = X+Y
   ...
50 CONTINUE
   X = A
   Y = B - A + C * C
   GO TO 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用終わり。&lt;/p&gt;

&lt;p&gt;条件分岐の際、実行するコードを選ぶために明示的に行番号を指定してジャンプしています。
このコードでは、50 から 11 に戻ることでループを作っています。
フラットなコードなので、どこがループしているのがよく読まないとわかりません。
さらにはループの途中にジャンプする、のようなことも書けてしまうため、複雑に入り組んだスパゲティコードを量産することが可能でした&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。
そのため、無制限なジャンプを許さないようにプログラム言語が発展します。&lt;/p&gt;

&lt;h2 id=&#34;コードブロックベースのジャンプ&#34;&gt;コードブロックベースのジャンプ&lt;/h2&gt;

&lt;p&gt;昨今の言語では条件分岐やループの際に &lt;code&gt;{ }&lt;/code&gt; やインデントルールでコードブロックを示すことで、
言語処理系がいい感じにジャンプしてくれます。
また、&lt;code&gt;break&lt;/code&gt;や&lt;code&gt;continue&lt;/code&gt;のような、やはりコードブロックベースのジャンプが広く採用されています。&lt;/p&gt;

&lt;h2 id=&#34;例外機構&#34;&gt;例外機構&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if-then-else&lt;/code&gt;などで記述できないパターンのジャンプとして例外機構が生まれます。
その名の通り例外的なケースに際してコードブロックや関数呼び出しを抜けるためのものですが、
それが実際に例外的なケースであるかどうかまで処理系がチェックするわけではありません。&lt;/p&gt;

&lt;p&gt;そのため、例外機構というのは言語が提供する機能としては「値を渡せるジャンプ」です。
典型的には&lt;code&gt;try { ... } catch(e) { ... }&lt;/code&gt;のような構文で、&lt;code&gt;try&lt;/code&gt;ブロックの実行中に例外が投げられると、対応する&lt;code&gt;catch&lt;/code&gt;ブロックへ移動します。
注意が必要なのは、対応する&lt;code&gt;catch&lt;/code&gt;ブロックが見つかるまでコールスタックを戻りつつ探す点です。
つまり、&lt;code&gt;try-catch&lt;/code&gt; に辿り着くたび &lt;code&gt;catch&lt;/code&gt; ブロックの情報がスタックに積まれ、ジャンプ先は実行時の関数呼び出し履歴に基いて決まります。&lt;/p&gt;

&lt;h1 id=&#34;例外機構を使いたいケース&#34;&gt;例外機構を使いたいケース&lt;/h1&gt;

&lt;p&gt;例外機構によってできることは以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;エラー値返却の表現&lt;/li&gt;
&lt;li&gt;処理の中止および制御フローの移動&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、これによって生まれるメリットは以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ネストした処理(多重ループ、再帰呼び出しなど)をまとめて中止できる&lt;/li&gt;
&lt;li&gt;事前のエラーチェックを省ける&lt;/li&gt;
&lt;li&gt;エラー処理を一箇所にまとめられる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ネストした処理をまとめて中止できることの例&#34;&gt;ネストした処理をまとめて中止できることの例&lt;/h2&gt;

&lt;p&gt;CIPL p.214 の例を示します。&lt;/p&gt;

&lt;p&gt;木構造の中にある数値をすべて掛け合わせる &lt;code&gt;prod&lt;/code&gt; を考えます。
乗算なのでどこかにゼロが存在すると結果もゼロになるため、残りの計算が無駄です。
再帰呼び出しで木を辿っているとコールスタックが伸びていきますが、
例外機構を使えば処理を中止してまとめてスタックを戻り、ゼロを返すということが可能です。&lt;/p&gt;

&lt;h2 id=&#34;事前のエラーチェックを省ける例&#34;&gt;事前のエラーチェックを省ける例&lt;/h2&gt;

&lt;p&gt;CIPL p.208 の例を示します。&lt;/p&gt;

&lt;p&gt;A の逆行列を求める関数 &lt;code&gt;invert&lt;/code&gt; を考えます。
まず行列式 &lt;code&gt;det(A)&lt;/code&gt; を求め、これを利用することで逆行列が得られますが、&lt;code&gt;det(A)&lt;/code&gt;がゼロの場合には逆行列が存在しません。
しかしながら &lt;code&gt;invert&lt;/code&gt; を使う前に、&lt;code&gt;det(A)&lt;/code&gt; を計算して値をチェックするのは&lt;code&gt;invert&lt;/code&gt;での処理と重複してしまいイマイチです。&lt;/p&gt;

&lt;p&gt;なのでとりあえず &lt;code&gt;invert&lt;/code&gt; 内でとりあえず det(A) を計算し、ゼロであれば例外を投げてエラー値を表現し、処理を中止するということが可能です。&lt;/p&gt;

&lt;h2 id=&#34;エラー処理を一箇所にまとめたいケース&#34;&gt;エラー処理を一箇所にまとめたいケース&lt;/h2&gt;

&lt;p&gt;CIPL には載っていないですが例外機構の利用例としてよく見かけるものです。
&lt;code&gt;try&lt;/code&gt;ブロックで複数種類のエラーが発生し得る、エラー処理が長い、などの状況では、
正常系の機能コードとエラー処理のコードが混在するのが好ましくありません。
これらを分離するために例外を利用し、エラー処理については&lt;code&gt;catch&lt;/code&gt;ブロックにまとめることができます。&lt;/p&gt;

&lt;h1 id=&#34;例外機構を使うべきでないケース&#34;&gt;例外機構を使うべきでないケース&lt;/h1&gt;

&lt;p&gt;個人的に面白いなと思ったのでメモしておきます。&lt;/p&gt;

&lt;p&gt;「catch ブロックを探すためのスタック巻きとりにかかる時間を予測しにくいため、リアルタイム性が損なわれる」というもの。
組込み機器で計算機資源が乏しかったり、あるいは処理時間について厳密に予測しなければならないケースには、例外機構は向いていません。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://softwareengineering.stackexchange.com/questions/258012/why-design-a-modern-language-without-an-exception-handling-mechanism&#34;&gt;Why design a modern language without an exception-handling mechanism?&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In embedded programming, exceptions were traditionally not allowed, because the overhead of the stack unwinding you have to do was deemed an unacceptable variability when trying to maintain real-time performance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/MasayaMizuhara/items/98c0d490f1633d9b636f&#34;&gt;もう少し例外を使用しても良いのではないか&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;例えば 組み込みシステムのような厳しい処理速度が要求されるケース では例外を使用すべきではない(例外を throw してから catch するまでの最大時間を正確に測定することが困難なため)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;go言語でのやり方&#34;&gt;Go言語でのやり方&lt;/h1&gt;

&lt;h2 id=&#34;ネストした処理を中止する&#34;&gt;ネストした処理を中止する&lt;/h2&gt;

&lt;p&gt;多重ループであれば &lt;code&gt;return&lt;/code&gt;、&lt;code&gt;break&lt;/code&gt; あるいは &lt;code&gt;goto&lt;/code&gt; が使えます。
コールスタックを戻りたい場合は &lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;panic&lt;/code&gt;、&lt;code&gt;recover&lt;/code&gt; を使います。&lt;/p&gt;

&lt;h2 id=&#34;エラー値返却の表現&#34;&gt;エラー値返却の表現&lt;/h2&gt;

&lt;p&gt;多値返却できるため、値としてエラーを返します。&lt;/p&gt;

&lt;h2 id=&#34;エラー処理を一箇所にまとめる&#34;&gt;エラー処理を一箇所にまとめる&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;です。これは数少ない &lt;code&gt;goto&lt;/code&gt; が有用なケースのうちのひとつです。
ただし、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if err != nil { goto ErrorHandling; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいなコードはあちこちに残ります。&lt;/p&gt;

&lt;h1 id=&#34;例外機構が並行プログラムで使えない理由&#34;&gt;例外機構が並行プログラムで使えない理由&lt;/h1&gt;

&lt;p&gt;スレッド間ではスタックを共有しないためです。
(参考：&lt;a href=&#34;http://www.lighterra.com/papers/exceptionsharmful/&#34;&gt;Exception Handling Considered Harmful&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;ここまでの説明では、例外が投げられたとき、対応する &lt;code&gt;catch&lt;/code&gt; ブロックをコールスタックから探すという挙動でした。
POSIXスレッドにも&lt;a href=&#34;https://www.ibm.com/developerworks/jp/linux/library/l-posix1/#f&#34;&gt;親子の概念がない&lt;/a&gt;ですし、
スレッド間で暗黙的に例外が伝わるような仕様は難しそうです。&lt;/p&gt;

&lt;p&gt;C++ や Java をちょろっと調べた感じでは、スレッド間で例外の情報を伝える際には何かしら共有メモリ方式を使うようです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://phst.hateblo.jp/entry/2016/09/10/205618&#34;&gt;マルチスレッドにおける例外処理の受け渡し (VC++)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://minor.hatenablog.com/entry/20101130/1291125150&#34;&gt;スレッドがスローする例外をキャッチする&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- [Erlang と Golang を比較してみる](http://qiita.com/soranoba/items/68d57b4635a2917f3c73) --&gt;

&lt;!-- [Semipredicate problem](https://en.wikipedia.org/wiki/Semipredicate_problem) --&gt;

&lt;!-- [Go, for Distributed System](https://talks.golang.org/2013/distsys.slide#1) --&gt;

&lt;h1 id=&#34;例外機構に対する批判&#34;&gt;例外機構に対する批判&lt;/h1&gt;

&lt;p&gt;前節までに調べたことで、個人的には「例外機構でやりたいことは Go 言語の他の機能でもカバーできそうだ」という気持ちになりました。
また、「並行プログラムを念頭に置くなら例外機構は筋が悪そう」とも思います。&lt;/p&gt;

&lt;p&gt;ですがそれだけだと「例外機構ではコードが入り組んでしまう」という説明にはならないので、例外機構への批判を探してみました。&lt;/p&gt;

&lt;p&gt;大体「関数の出口が増えるため、制御フローが複雑になる」という感じの指摘でしょうか。
&lt;a href=&#34;http://local.joelonsoftware.com/wiki/%E9%96%93%E9%81%95%E3%81%A3%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E9%96%93%E9%81%95%E3%81%A3%E3%81%A6%E8%A6%8B%E3%81%88%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B&#34;&gt;間違ったコードは間違って見えるようにする&lt;/a&gt;から引用すると、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本当の問題は、例外がコロケーションを殺してしまうということだ。コードが正しいことをしているかという質問に答えるためには、どこか別なところを見なければならず、あなたの目の持つまずいコードを見つけ出す能力が生かせないことになる。そこには見えるものがないからだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ということで、明示的に &lt;code&gt;return&lt;/code&gt; が書いてあるのに比べて関数を抜ける可能性に気づきにくく、不正な状態に落ち入りやすくなるのを嫌っているという理解です。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/oldnewthing/20040422-00/?p=39683&#34;&gt;Cleaner, more elegant, and wrong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/oldnewthing/20050114-00/?p=36693&#34;&gt;Cleaner, more elegant, and harder to recognize&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://local.joelonsoftware.com/wiki/%E9%96%93%E9%81%95%E3%81%A3%E3%81%9F%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E9%96%93%E9%81%95%E3%81%A3%E3%81%A6%E8%A6%8B%E3%81%88%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B&#34;&gt;間違ったコードは間違って見えるようにする&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joelonsoftware.com/2003/10/13/13/&#34;&gt;Joel on software: 2003/10/13&lt;/a&gt;&lt;a href=&#34;http://d.hatena.ne.jp/kmaebashi/20091227/p1&#34;&gt;とその翻訳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/1736146/why-is-exception-handling-bad&#34;&gt;StackOverflow: Why is exception handling bad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://xahlee.info/comp/why_i_hate_exceptions.html&#34;&gt;Why I Hate Exceptions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;個人の感想です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;例外機構が欲しい場面は Go 言語の他の機能でカバーできそう&lt;/li&gt;
&lt;li&gt;例外機構によるエラー返却では、関数の出口が増えるため制御フローが複雑になる&lt;/li&gt;
&lt;li&gt;エラー値返却の手段としての例外機構は、並行プログラムにそぐわないので Go 言語は例外機構を採用しなかった&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;この時代には、何しろ計算機資源が少ないので、そうしたジャンプを駆使してコードサイズ・命令数を削減することも重要だったようです。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Go言語で union とか直和型のようなデータを表現したいときは interface を使う</title>
      <link>https://tmrtmhr.info/tech/sum-type-in-golang/</link>
      <pubDate>Wed, 29 Mar 2017 22:46:34 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/sum-type-in-golang/</guid>
      <description>&lt;p&gt;たとえば Haskell では以下のようなデータ型を定義できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data Tree = Leaf | Branch Tree Tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C言語で言えばタグ付き共用体(union)のような感じです。&lt;/p&gt;

&lt;!-- ``` --&gt;

&lt;!-- union Tree { --&gt;

&lt;!--   struct Leaf { --&gt;

&lt;!--     tag int; --&gt;

&lt;!--   } leaf; --&gt;

&lt;!--   struct Branch { --&gt;

&lt;!--     tag int; --&gt;

&lt;!--     left *Tree; --&gt;

&lt;!--     right *Tree; --&gt;

&lt;!--   } branch; --&gt;

&lt;!-- } --&gt;

&lt;!-- ``` --&gt;

&lt;p&gt;この記事は、こんな感じで木構造などを表現したい時
Go 言語ではどうするのか？という点について調べてみたメモです。
結論としては&lt;code&gt;type Tree interface{ ... }&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;data Tree a&lt;/code&gt; のように汎用的なコンテナを作る方法については言及しません。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;leaf-と-branch-に対して行いたい操作&#34;&gt;Leaf と Branch に対して行いたい操作&lt;/h1&gt;

&lt;p&gt;ここでは&lt;code&gt;Tree&lt;/code&gt;中の&lt;code&gt;Leaf&lt;/code&gt;を数える&lt;code&gt;Count&lt;/code&gt;という関数を考えてみます。
Haskell だったらパターンマッチで分岐です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;count :: Tree -&amp;gt; Int
count Leaf = 1
count (Branch l r) = count l + count r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今Go言語で実現したいのは以下のような内容です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt;か&lt;code&gt;Branch&lt;/code&gt;のどちらかのデータ構造を引数に取る&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt;か&lt;code&gt;Branch&lt;/code&gt;かによって処理を分岐する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そこで登場するのが &lt;code&gt;interface&lt;/code&gt; です。
ここで&lt;code&gt;Leaf&lt;/code&gt;と&lt;code&gt;Branch&lt;/code&gt;は&lt;code&gt;count&lt;/code&gt;という共通のインタフェースを持っているわけなので、
そういうふうに書きます。&lt;/p&gt;

&lt;p&gt;そんなわけでコードは以下の通りです。&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/tmrtmhr/3134ee6b7201197471e33f98780e1285.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;ということでGo言語で木構造のような直和型のデータ構造を扱う小さな例を示しました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GO言語で雛形JSONの内容をコマンド出力の内容で置換する</title>
      <link>https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/</link>
      <pubDate>Tue, 14 Mar 2017 18:04:09 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/</guid>
      <description>&lt;p&gt;AWS CLI によりコマンドラインから制御したりする際、リクエストパラメータとして JSON ファイルが必要になることがあります。
&lt;a href=&#34;https://tmrtmhr.info/tech/aws/delete-updated-file-cache-on-cloudfront/&#34;&gt;CloudFront のキャッシュを削除したいとき&lt;/a&gt;なんかがそうです。&lt;/p&gt;

&lt;p&gt;AWS CLI のコマンドごとに、リクエストJSONを生成する専用スクリプトを書くという手もありますが、
シェル上でパイプやらリダイレクトやらを駆使していい感じに JSON を生成できるある程度汎用的なスクリプトにならんものか、
という思いから試してみた結果をここに記します。
どこかに既にあるものでしたらすみません。&lt;/p&gt;

&lt;p&gt;コマンド引数は以下のようになっていて、JSON ファイルは標準入力から与えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;filljson ${入力の型} ${キーパス} ${入力ファイル名}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;標準入出力で JSON をやりとりするので以下のようにパイプでつなげることで
中間ファイルを作ることなく最終的なリクエスト JSON が得られます。
入力ファイル名のところには &lt;code&gt;bash&lt;/code&gt; や &lt;code&gt;zsh&lt;/code&gt; のプロセス置換機能を利用しています。
プロセス置換機能を使うとプログラム側からは単にファイルパスが渡ってくるように見えるので、
ファイルIOとして処理すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat json/cloudfront-invalidation.json |
  filljson int InvalidationBatch.Paths.Quantity &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | wc -l) |
  filljson [string] InvalidationBatch.Paths.Items &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | sed -e &#39;s/^public//g&#39;) |
  filljson string InvalidationBatch.CallerReference &amp;lt;(date +&amp;quot;osone3-%Y/%m/%d-%H:%k:%m&amp;quot; | tr -d &#39;\n&#39;) |
  jq . &amp;gt; request.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;プログラムの内容&#34;&gt;プログラムの内容&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tmrtmhr/filljson&#34;&gt;コードはここ&lt;/a&gt;で、
Go 言語で書いたので &lt;code&gt;go get github.com/tmrtmhr/filljson&lt;/code&gt; でコマンドをインストールできます。
リポジトリの &lt;code&gt;js/filljson.js&lt;/code&gt; に node.js で実装したものもあります。&lt;/p&gt;

&lt;p&gt;どこかでエラーが出たら死にます(&lt;code&gt;os.Exit(1)&lt;/code&gt;)。
テストコードは少しだけ書きました。&lt;/p&gt;

&lt;p&gt;入力としては配列を想定しておらず、オブジェクトのみなので &lt;code&gt;map[string]interface{}&lt;/code&gt; 型を &lt;code&gt;json.Unmarshal&lt;/code&gt; に渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var jsonData map[string]interface{}
err = json.Unmarshal(jsonStr, &amp;amp;jsonData)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取り出した値が &lt;code&gt;interface{}&lt;/code&gt; となっているので再度 &lt;code&gt;map[string]interface{}&lt;/code&gt;として型アサーションをつけます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;finger = finger[propName].(map[string]interface{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.kaoriya.net/blog/2016/06/25/&#34;&gt;golang は ゆるふわに JSON を扱えまぁす!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;雑感&#34;&gt;雑感&lt;/h1&gt;

&lt;p&gt;標準入出力は偉大です。&lt;/p&gt;

&lt;p&gt;GO言語的には特化した(たとえばCloudFront専用のJSON生成専用)コマンドを作ってきっちり型検査したほうが良さそうですが、
まあこういう書き方もできるということで御参考いただければ幸いです。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git diff を利用して更新のあったファイルのみ CloudFront のキャッシュを削除する</title>
      <link>https://tmrtmhr.info/tech/aws/delete-updated-file-cache-on-cloudfront/</link>
      <pubDate>Tue, 14 Mar 2017 17:15:21 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/aws/delete-updated-file-cache-on-cloudfront/</guid>
      <description>&lt;p&gt;本サイトは Hugo で生成したものを GitHub Pages に push して公開し、
CloudFront を利用して配信しています。
CloudFront はキャッシュサーバとして働くので、
何もしなければ TTL が切れるまでは古いコンテンツが表示されます。&lt;/p&gt;

&lt;p&gt;単純にキャッシュ全削除という手もありますが、
せっかくなので更新のあったファイルのみキャッシュを削除してみました。&lt;/p&gt;

&lt;p&gt;やっていることは以下のような感じです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git diff&lt;/code&gt; で更新のあったファイル一覧を取得&lt;/li&gt;
&lt;li&gt;一覧を加工して AWS CLI 用の JSON ファイルを生成&lt;/li&gt;
&lt;li&gt;AWS CLI の &lt;code&gt;aws cloudfront create-invalidation&lt;/code&gt; でキャッシュ削除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;前提-ブログデータを管理するリポジトリの構成&#34;&gt;前提：ブログデータを管理するリポジトリの構成&lt;/h1&gt;

&lt;p&gt;本サイトの構成では以下の二種類のリポジトリが登場します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Markdown などを管理するリポジトリ(&lt;code&gt;blog-hugo&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;生成したHTMLを GitHub Pages で公開するリポジトリ(&lt;code&gt;tmrtmhr.github.io&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;blog-hugo/public&lt;/code&gt; に &lt;code&gt;tmrtmhr.github.io&lt;/code&gt; を &lt;code&gt;subtree&lt;/code&gt; として取り込んでいます。&lt;/p&gt;

&lt;p&gt;この構成は、昔&lt;a href=&#34;http://gohugo.io/tutorials/github-pages-blog/#hosting-personal-organization-pages&#34;&gt;「Hugo チュートリアル：GitHub Pages で個人ページを公開する」&lt;/a&gt;
を参考にして言われるがままに構成したのですが、
現在は &lt;code&gt;submodule&lt;/code&gt; として取り込んで、&lt;code&gt;public&lt;/code&gt; 以下のみ &lt;code&gt;push&lt;/code&gt; するようになっており、
Markdown のほうの管理には言及がなくなったようです。&lt;/p&gt;

&lt;h1 id=&#34;更新のあったファイル一覧の取得&#34;&gt;更新のあったファイル一覧の取得&lt;/h1&gt;

&lt;p&gt;Hugo で生成した HTML ファイル群は &lt;code&gt;public&lt;/code&gt; ディレクトリ以下に出来上がりますが、
全記事を再生成するのでタイムスタンプがほぼ同じとなります。
なので、&lt;code&gt;find public -mmin -5&lt;/code&gt;のようにして5分以内に更新のあったファイルを探して……というアプローチではうまくいきません。&lt;/p&gt;

&lt;p&gt;というわけで &lt;code&gt;git diff&lt;/code&gt; を使います。
&lt;code&gt;--diff-filter=M&lt;/code&gt; で更新のあったファイルのみの抽出、&lt;code&gt;--name-only&lt;/code&gt;でパスのみの表示、&lt;code&gt;HEAD^ HEAD&lt;/code&gt; で一つ前と最新との比較、&lt;code&gt;public&lt;/code&gt; で対象のディレクトリを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git diff --diff-filter=M --name-only HEAD^ HEAD public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://qiita.com/kaminaly/items/28f9cb4e680deb700833&#34;&gt;gitで差分ファイルを抽出する&lt;/a&gt;、&lt;a href=&#34;https://git-scm.com/docs/git-diff&#34;&gt;git diff のオプション&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ファイル一覧を-json-ファイルへ加工&#34;&gt;ファイル一覧を JSON ファイルへ加工&lt;/h1&gt;

&lt;p&gt;AWS CLI で CloudFront にキャッシュ削除したいファイルパスを送る際、
コマンド引数として &lt;code&gt;--paths&lt;/code&gt; も利用できますが、
ファイル数が増えてくると&lt;a href=&#34;https://www.ecoop.net/memo/archives/2010-01-26-1.html&#34;&gt;コマンド引数の長さ制限&lt;/a&gt;に引っかかりそうなので、
JSON を構築することにします。&lt;/p&gt;

&lt;p&gt;AWS CLI から CloudFront にキャッシュ削除リクエストを投げるための雛形JSONが以下のコマンドで得られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aws cloudfront create-invalidation --generate-cli-skeleton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注： AWS CLI のバージョン &lt;code&gt;aws-cli/1.11.58&lt;/code&gt; においても &lt;code&gt;cloudfront&lt;/code&gt; コマンドはプレビュー版なので
&lt;code&gt;aws configure set preview.cloudfront true&lt;/code&gt; とコマンドを打って設定ファイルを書き換えてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;DistributionId&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;InvalidationBatch&amp;quot;: {
        &amp;quot;Paths&amp;quot;: {
            &amp;quot;Quantity&amp;quot;: 0,
            &amp;quot;Items&amp;quot;: [
                &amp;quot;&amp;quot;
            ]
        },
        &amp;quot;CallerReference&amp;quot;: &amp;quot;&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DistributionId&lt;/code&gt;: 対象とする CloudFront ディストリビューションID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Items&lt;/code&gt;: ファイルパスのリスト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Quantity&lt;/code&gt;: ファイルパスの数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallerReference&lt;/code&gt;: こちらで自由に指定するリクエストのID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;CallerReference&lt;/code&gt; は、&lt;a href=&#34;http://docs.aws.amazon.com/cli/latest/reference/cloudfront/create-invalidation.html&#34;&gt;AWS CLI のリファレンス&lt;/a&gt;によると
「間違って同じリクエストが重複しないよう」に使われます。
まったく同じリクエストを投げた場合は新しい Invalidation Batch は作られず、
&lt;code&gt;CallerReference&lt;/code&gt;が重複していて &lt;code&gt;Items&lt;/code&gt; の内容が異なるような場合は &lt;code&gt;InvalidationBatchAlreadyExists&lt;/code&gt; となるようです。
とりあえず時刻に基いて生成すれば良いかと思います。&lt;/p&gt;

&lt;p&gt;この雛形JSONに対しコマンド出力をはめこんでリクエストを作ります。
&lt;a href=&#34;https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/&#34;&gt;この加工のためのスクリプト&lt;/a&gt;は別記事にしていますので
詳細についてはそちらをご参照ください。&lt;/p&gt;

&lt;p&gt;こういったスクリプトがあると、以下のようにして、雛形となるJSONにコマンドの出力を当てはめていって最終的なリクエストJSONを得られます。
(&lt;code&gt;DistributionId&lt;/code&gt; についてはあらかじめ JSON に書いてあります)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat json/cloudfront-invalidation.json |
  filljson int InvalidationBatch.Paths.Quantity &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | wc -l) |
  filljson [string] InvalidationBatch.Paths.Items &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | sed -e &#39;s/^public//g&#39;) |
  filljson string InvalidationBatch.CallerReference &amp;lt;(date +&amp;quot;tmrtmhr-%Y/%m/%d-%H:%k:%m&amp;quot; | tr -d &#39;\n&#39;) |
  jq . &amp;gt; request.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;aws-cli-を使用した-cloudfront-のキャッシュ削除&#34;&gt;AWS CLI を使用した CloudFront のキャッシュ削除&lt;/h1&gt;

&lt;p&gt;前項でリクエストJSONを生成したので、それを投げます。
使用する profile については適宜指定してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aws cloudfront create-invalidation --cli-input-json file://request.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;invalidation-の注意点&#34;&gt;Invalidation の注意点&lt;/h1&gt;

&lt;p&gt;月間 1000 ファイルパスまでは無料、以降は $0.005 / 1パスとなるようなので、
更新が頻繁にある・更新ファイル数が多いなどで Invaliation を乱発するケースでは追加で料金が発生します。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://dev.sukimash.com/aws/cloud-front-invalidation/&#34;&gt;CLOUD FRONT の INVALIDATION が有料だなんて知らんかった&lt;/a&gt;、&lt;a href=&#34;https://aws.amazon.com/jp/cloudfront/pricing/&#34;&gt;CloudFront: 料金&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; の結果から CloudFront のキャッシュ削除を行う例を示しました。
リクエストのための JSON 生成については&lt;a href=&#34;https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/&#34;&gt;補助スクリプト&lt;/a&gt;を作って公開しています。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ブログに使うドメインを AWS で取得する</title>
      <link>https://tmrtmhr.info/tech/aws/register-a-domain-for-blog/</link>
      <pubDate>Tue, 14 Mar 2017 17:03:40 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/aws/register-a-domain-for-blog/</guid>
      <description>&lt;p&gt;せっかくなので本サイトのドメインを AWS Route53 で管理するようにした際のメモです。&lt;/p&gt;

&lt;p&gt;やったことは以下の通り。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/route53/&#34;&gt;Route 53&lt;/a&gt; でドメインを取得&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/ses/&#34;&gt;SES&lt;/a&gt; で対象ドメインのメールアドレスにて受信&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/certificate-manager/&#34;&gt;Certificate Manager&lt;/a&gt; で対象ドメインのSSL証明書を取得&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/cloudfront/&#34;&gt;CloudFront&lt;/a&gt; に取得したSSL証明書を設定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なお、今のところ CloudFront のオリジンサーバとしては &lt;a href=&#34;https://aws.amazon.com/jp/s3/&#34;&gt;S3&lt;/a&gt; ではなく &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt; を使用しています。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;なぜ-aws-でドメインを取得したか&#34;&gt;なぜ AWS でドメインを取得したか&lt;/h1&gt;

&lt;p&gt;ドメインの料金だけだと&lt;a href=&#34;www.onamae.com&#34;&gt;お名前.com&lt;/a&gt;などのように Route 53 より安いところもあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;取得したドメインでのメール受信設定( MX レコードの登録)を SES がやってくれるため楽&lt;/li&gt;
&lt;li&gt;SSL証明書が無料かつ自動更新&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで、要するに設定や管理の手間を省くことを重視したためです。&lt;/p&gt;

&lt;h1 id=&#34;route-53-におけるドメイン管理者情報の公開範囲について&#34;&gt;Route 53 におけるドメイン管理者情報の公開範囲について&lt;/h1&gt;

&lt;p&gt;Route 53 でドメインを取得する際、管理者情報を隠すかどうかのチェックボックスがありますが、
トップレベルドメインによって秘匿できる項目が異なります。
(参考：&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/route53-privacy-protection/&#34;&gt;Route 53で管理するドメインでプライバシー保護できるWHOIS項目は、ドメインによって違うので注意&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;本サイトのような&lt;a href=&#34;http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/registrar-tld-list.html#info&#34;&gt;.info ドメイン&lt;/a&gt; の場合は
名前だけが公開されます。
残りの項目はドメインレジストラである &lt;a href=&#34;https://www.gandi.net/&#34;&gt;Gandi&lt;/a&gt; の情報に置換されます。&lt;/p&gt;

&lt;h1 id=&#34;ドメイン取得時に登録するメールアドレスについて&#34;&gt;ドメイン取得時に登録するメールアドレスについて&lt;/h1&gt;

&lt;p&gt;今回、ドメイン取得時に登録するメールアドレスについても該当ドメインを使用することにしました( a&amp;#100;mi&amp;#110;&amp;#64;&amp;#116;m&amp;#114;tmhr.in&amp;#102;o )。
当然ながらドメイン取得申請の段階ではこのメールアドレスで受信することはできません。
ドメインを申請すると Route 53 からメールが送信され、本文中の URL にアクセスすることで取得完了となりますが、
期限に猶予があるため、その間に SES の設定を済ませることになります。&lt;/p&gt;

&lt;p&gt;Route 53 でドメイン申請 &lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  arrow_forward
&lt;/i&gt;
 SES で MX レコード登録 &lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  arrow_forward
&lt;/i&gt;
 Route 53 から送られてくるメール本文の URL にアクセス、という流れです。&lt;/p&gt;

&lt;p&gt;ここで、Certificate Manager での SSL 証明書取得を予定していて、かつドメインの管理者情報を秘匿している場合は注意が必要です。
Certificate Manager でもドメイン認証のためにメールが発信されますが、宛先は以下のように固定されます。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;whois&lt;/code&gt; で取得できる管理者メールアドレス&lt;/li&gt;
&lt;li&gt;ドメインに次の接頭辞をつけた 5 個のメールアドレス: &lt;code&gt;admin@&lt;/code&gt;, &lt;code&gt;administrator@&lt;/code&gt;,&lt;code&gt;hostmaster@&lt;/code&gt;, &lt;code&gt;webmaster@&lt;/code&gt;, &lt;code&gt;postmaster@&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;管理者情報を秘匿した場合は &lt;code&gt;whois&lt;/code&gt; で取得できるメールアドレスがドメインレジストラのものになりますので、
(2)のアドレスのどれかを登録しておきます。&lt;/p&gt;

&lt;h1 id=&#34;ses-で受信したメールに対するアクションについて&#34;&gt;SES で受信したメールに対するアクションについて&lt;/h1&gt;

&lt;p&gt;認証のための URL がわかれば十分であり、
Route 53 と Certificate Manager から送られる二通を読めればよいので、
今回は単純に S3 へ保存しました。&lt;/p&gt;

&lt;h1 id=&#34;ssl証明書を取得するリージョンについて&#34;&gt;SSL証明書を取得するリージョンについて&lt;/h1&gt;

&lt;p&gt;Certificate Manager で取得した SSL 証明書は、取得したリージョンでのみ利用することができます。
CloudFront はグローバルなサービスのため、Webコンソール上でリージョンを選択できませんが、
便宜的に &lt;code&gt;US East(N. Virginia)&lt;/code&gt; で設定するという扱いのためSSL 証明書もここで取得します。&lt;/p&gt;

&lt;h1 id=&#34;料金について&#34;&gt;料金について&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/Route53/latest/DeveloperGuide/domain-transfer-to-route-53.html&#34;&gt;ドメインの料金は AWS クレジットでは支払えない&lt;/a&gt;ため、
クレジットが残っていても料金が発生することに注意が必要です。&lt;/p&gt;

&lt;h1 id=&#34;cloudfront-が持つキャッシュについて&#34;&gt;CloudFront が持つキャッシュについて&lt;/h1&gt;

&lt;p&gt;デフォルトのままの設定だと TTL が 86400 秒となるので、GitHub Pages にデプロイしてから
最大一日程度は古いコンテンツが表示されます。
デプロイの際にスクリプトからキャッシュ削除リクエストを発行するようにすれば良いと思います。
&lt;a href=&#34;https://tmrtmhr.info/tech/aws/delete-updated-file-cache-on-cloudfront/&#34;&gt;実装はこちら。&lt;/a&gt;&lt;/p&gt;

&lt;!-- 詰まったところ --&gt;

&lt;!-- CloudFront に Alternate CNAME 設定し忘れ --&gt;

&lt;!-- http://blog.ybbo.net/2015/04/11/how-to-fix-error-of-error-the-request-could-not-be-satisfied-generated-by-cloudfront-cloudfront-on-aws-cloud-front/ --&gt;</description>
    </item>
    
    <item>
      <title>Hugo でマテリアルアイコンを使うための ShortCode</title>
      <link>https://tmrtmhr.info/tech/hugo-with-material-icon/</link>
      <pubDate>Wed, 08 Mar 2017 08:52:50 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/hugo-with-material-icon/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; で任意の HTML を生成したい場合は &lt;a href=&#34;https://gohugo.io/extras/shortcodes/&#34;&gt;ShortCode&lt;/a&gt; を書くことになります。&lt;/p&gt;

&lt;p&gt;本サイトでは使い道はさておきマテリアルアイコンを読み込んでいるので、
ShortCode で使えるようにしてみました。
&lt;/p&gt;

&lt;h1 id=&#34;hugo-からマテリアルアイコンを使う手順&#34;&gt;Hugo からマテリアルアイコンを使う手順&lt;/h1&gt;

&lt;p&gt;まず &lt;code&gt;themes/${テーマ名}/layouts/partials/header.html&lt;/code&gt; などに以下を追記してマテリアルアイコンのフォントを読み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://fonts.googleapis.com/icon?family=Material+Icons&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;layouts/shortcodes/md-icon.html&lt;/code&gt; として以下の内容を用意し、ShortCode として使えるようにします。&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/tmrtmhr/90cff33e3e18fbc10f8daf9dac753b30.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;ここで、&lt;code&gt;vertical-align: bottom;&lt;/code&gt; はアイコンと文章の高さをそろえるための指定です。
また、&lt;code&gt;.Get 0&lt;/code&gt; で ShortCode の引数を取得しています。&lt;/p&gt;

&lt;p&gt;Markdown ファイル中では以下のように書きます。これにより &lt;code&gt;favorite&lt;/code&gt; が &lt;code&gt;.Get 0&lt;/code&gt; の部分に埋め込まれた HTML を生成します。&lt;/p&gt;

&lt;p&gt;{{&amp;lt; md-icon favorite &amp;gt;}}&lt;/p&gt;

&lt;p&gt;&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;

表示はこんな感じです
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;/p&gt;

&lt;h1 id=&#34;なぜ-raw-html-ではなく-shortcode-を書くのか&#34;&gt;なぜ Raw HTML ではなく ShortCode を書くのか&lt;/h1&gt;

&lt;p&gt;Markdown は &lt;a href=&#34;http://daringfireball.net/projects/markdown/syntax#html&#34;&gt;HTMLを埋め込める&lt;/a&gt;ため、
アイコン表示の HTML (前述の Gist)を直接書いても表示されます。&lt;/p&gt;

&lt;p&gt;ではなぜ ShortCode として用意するのかというと、
&lt;a href=&#34;https://gohugo.io/extras/shortcodes/&#34;&gt;公式サイトの説明&lt;/a&gt;にある通り、
以下のような利点があるためです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定型のHTMLを毎回書かずにすむ&lt;/li&gt;
&lt;li&gt;ShortCode を変更することで該当の HTML 部分がすべて置き換わるので更新が楽にすむ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そんなわけで、一生に一度の HTML だと心に決めている、というのでなければ、
ShortCode 化して再利用するほうが良いかと思います。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Emacs から外部プロセスを呼び出して結果をエコーエリアに表示する</title>
      <link>https://tmrtmhr.info/tech/call-process-on-emacs/</link>
      <pubDate>Mon, 22 Feb 2016 16:16:21 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/call-process-on-emacs/</guid>
      <description>&lt;p&gt;学生時代からの習慣と宗教上の理由から普段使いのエディタは Emacs
(ここでは &lt;a href=&#34;http://emacsformacosx.com/&#34;&gt;GNU Emacs for Mac OS X&lt;/a&gt;)
です。&lt;/p&gt;

&lt;p&gt;設定ファイルを除いて自分で Emacs Lisp を書いて機能を追加したことはこれまで無かったのですが、
このたび必要にかられて追加いたしました。
&lt;/p&gt;

&lt;p&gt;ど素人なので作法やらベストプラクティスやらがわからないですが、まあ動きます。
&lt;a href=&#34;https://gist.github.com/TAMURAtomohiro/18cd0fb0ae33baa48625&#34;&gt;Gist&lt;/a&gt; にも置いてあります。&lt;/p&gt;

&lt;h1 id=&#34;経緯&#34;&gt;経緯&lt;/h1&gt;

&lt;p&gt;とあるプロジェクトで JavaScript のソフトウェアメトリクスを測り、
コード改善のときの目安とすることになりました。
そこで&lt;a href=&#34;http://es-analysis.github.io/plato/examples/marionette/index.html&#34;&gt;Plato&lt;/a&gt;を導入したわけですが、
このツールでは今まさに自分が変更したファイルのメトリクスを確認するのが面倒です。&lt;/p&gt;

&lt;p&gt;どうせなら書いたそばから教えていただければ「もうちょっとメトリクス上げてみようか」という気分にもなるわけです。
before-save-hook などで保存時に何かしらの処理をフックできることは知っていましたので、
前述の plato を呼んで結果を表示するくらいのことはすぐできるだろう……と作り始めました。&lt;/p&gt;

&lt;h1 id=&#34;メトリクスを取り出す&#34;&gt;メトリクスを取り出す&lt;/h1&gt;

&lt;p&gt;plato には「結果を標準出力に出す」ようなオプションがなかったため、
とりあえずごり押しで plato の結果を取り出してみます。
生成された HTML から Average Maintainability の部分を取り出せれば細かいことはとやかく言いません。
(一時ファイルの名前やらが決め打ちじゃ並列実行したときおかしくなるぞ、とか)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
TMPFILE=/tmp/js-metrics.js
REPORT_DIR=/tmp
cat - &amp;gt; ${TMPFILE}
plato -d ${REPORT_DIR} ${TMPFILE} &amp;gt; /dev/null
grep &#39;class=&amp;quot;stat&amp;quot;&#39; ${REPORT_DIR}/index.html | tail -n 1 | sed -e &amp;quot;s/&amp;lt;p class=\&amp;quot;stat\&amp;quot;&amp;gt;//g&amp;quot; | sed -e &amp;quot;s/&amp;lt;\/p&amp;gt;//g&amp;quot; | sed -e &amp;quot;s/ //g&amp;quot; | tr -d &#39;\n&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;現在のバッファの内容を外部プロセスに渡し-結果をエコーエリアに表示する&#34;&gt;現在のバッファの内容を外部プロセスに渡し、結果をエコーエリアに表示する&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;call-process-region&lt;/code&gt; という関数を使うと現在のバッファの内容を標準入力として外部プロセスに渡せるのでこれを使います。
ただ、エコーエリアに表示しようとして、結果の出力先バッファを &lt;code&gt;*Messages*&lt;/code&gt; とするやり方はうまくいかず(&lt;code&gt;*Messages*&lt;/code&gt;バッファが read-only になっていて書き込めない)、
&lt;code&gt;message&lt;/code&gt; 関数を使うことになりました。&lt;/p&gt;

&lt;p&gt;なので出力先バッファを用意しなきゃいけないですが、
自分で管理するのは面倒なので &lt;code&gt;with-temp-buffer&lt;/code&gt; を使ってみます。
これを使うと新たなバッファが作られ、一連の処理が終わったあとに破棄してくれます。
カレントバッファが切り替わってしまうので今回の目的のためには
元バッファの JavaScript コードを取得しておいて転記する必要があります。&lt;/p&gt;

&lt;p&gt;ということで今回の成果物を以下の通りです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun jsmetrics ()
    (if (derived-mode-p &#39;js-mode) ; JavaScript ファイルが js-mode で開かれることを前提として JavaScript のみを対象とする
        (let ((jscode (buffer-string))) ; カレントバッファの内容を取得しておき
            (with-temp-buffer
                (insert jscode)         ; 一時バッファに書き込む
                (call-process-region (point-min) (point-max) &amp;quot;js-metrics.sh&amp;quot; t t nil) ; 一時バッファの内容を外部プロセスの結果で置き換える
                (message (buffer-string)))))) ; 結果をエコーエリアに表示

(add-hook &#39;js-mode-hook
    (lambda () (add-hook &#39;after-save-hook &#39;jsmetrics)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;標準入出力という偉大なインタフェースのおかげで Emacs Lisp 内で完結させる必要がなく、
他言語のモジュールを利用できるのが素晴らしいです。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Angular2 から Web Components を使う</title>
      <link>https://tmrtmhr.info/tech/angular2-web-components/</link>
      <pubDate>Mon, 22 Feb 2016 16:08:13 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/angular2-web-components/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://angular.io/&#34;&gt;Angular2&lt;/a&gt;が
&lt;a href=&#34;http://angularjs.blogspot.jp/2015/12/angular-2-beta.html&#34;&gt;昨年12月に Beta リリース&lt;/a&gt;されたため、
色々触りながら調べています。&lt;/p&gt;

&lt;p&gt;Angular2 の設計ドキュメントのひとつ(&lt;a href=&#34;https://docs.google.com/document/d/1kpuR512G1b0D8egl9245OHaG0cFh0ST0ekhD_g8sxtI/edit#heading=h.ptbnyo3pqsmq&#34;&gt;Data Binding with Web Components&lt;/a&gt;)
を見かけ、Web Components との併用を考慮しているようだったので、
使い方を調べてみることにしました。
&lt;/p&gt;

&lt;p&gt;この記事の&lt;a href=&#34;https://github.com/TAMURAtomohiro/angular2-with-web-components&#34;&gt;サンプルコード(TypeScript)&lt;/a&gt;をGitHubで公開しています。&lt;/p&gt;

&lt;h1 id=&#34;題材&#34;&gt;題材&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://elements.polymer-project.org/elements/google-map&#34;&gt;Google Map Web Component&lt;/a&gt;(以下 google-map と表記) を Angular2 から使用します。
やりたいことは以下の三種類です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DOM のプロパティを介して Web Components に値を渡す&lt;/li&gt;
&lt;li&gt;DOM のメソッドを呼ぶ&lt;/li&gt;
&lt;li&gt;DOM から上がってくるイベントを捕捉する&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;コンポーネントの構成&#34;&gt;コンポーネントの構成&lt;/h1&gt;

&lt;p&gt;Angular2 では Component(コンポーネント)という単位でモジュールを分けるようになりました。
ざっくり言うとテンプレートHTMLを持つ Directive を Component と呼びます。&lt;/p&gt;

&lt;p&gt;今回のコードでは &lt;code&gt;AppComponent&lt;/code&gt;(&lt;code&gt;app.component.ts&lt;/code&gt;) と &lt;code&gt;GoogleMapWebComponent&lt;/code&gt;(&lt;code&gt;googlemap.component.ts&lt;/code&gt;) の二種類です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AppComponent&lt;/code&gt; では google-map に渡す値やイベントハンドラを定義します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GoogleMapWebComponent&lt;/code&gt; は Angular2 から google-map を触るために DOM 要素を保持します。&lt;/p&gt;

&lt;h1 id=&#34;dom-のプロパティを介して-web-components-に値を渡す&#34;&gt;DOM のプロパティを介して Web Components に値を渡す&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;AppComponent&lt;/code&gt; のテンプレートにある &lt;code&gt;[latitude]=&amp;quot;lat&amp;quot;&lt;/code&gt; のような記述により google-map に Angular の値を渡すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;google-map [latitude]=&amp;quot;lat&amp;quot; [longitude]=&amp;quot;lng&amp;quot;&amp;gt;&amp;lt;/google-map&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値は同じく &lt;code&gt;AppComponent&lt;/code&gt; で以下のように定義してあります。右辺の &lt;code&gt;lat&lt;/code&gt;、&lt;code&gt;lng&lt;/code&gt; はこれを参照しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;constructor() {
    this.lat = 35.71;
    this.lng = 139.98;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;記法&#34;&gt;[ ] 記法&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[latitude]=&amp;quot;lat&amp;quot;&lt;/code&gt; は property binding と呼ばれ、
DOM のプロパティに右辺の式を一方向バインディングするという意味を持ちます。&lt;/p&gt;

&lt;p&gt;つまり、以下のようなコードで Angular2 のプロパティを更新すると、
&lt;code&gt;google-map&lt;/code&gt; HTML要素の &lt;code&gt;longitude&lt;/code&gt; プロパティも合わせて更新されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;goWest() {
    this.lng = this.lng - 0.1; // Angular 側のプロパティ更新が Web Components に反映される
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、地図をドラッグして移動しても、Angular2 の &lt;code&gt;lat&lt;/code&gt;、&lt;code&gt;lng&lt;/code&gt; プロパティは更新されません。
追従するためには &lt;code&gt;google-map-dragend&lt;/code&gt; のイベントを捕捉し、明示的に更新処理を書く必要があります。&lt;/p&gt;

&lt;p&gt;ここで、&lt;code&gt;GoogleMapWebComponent&lt;/code&gt; に &lt;code&gt;@Input&lt;/code&gt; デコレータを「書かない」ことに注意しましょう。
&lt;code&gt;@Input&lt;/code&gt; デコレータを書くとコンポーネントのプロパティに設定するようになり、
DOM のプロパティに設定されなくなってしまいます。&lt;/p&gt;

&lt;h1 id=&#34;dom-のメソッドを呼ぶ&#34;&gt;DOM のメソッドを呼ぶ&lt;/h1&gt;

&lt;h2 id=&#34;dom-を取得する&#34;&gt;DOM を取得する&lt;/h2&gt;

&lt;p&gt;DOM のメソッドを呼ぶにはまず DOM を取得する必要があります。
(一休さんで言うところの、虎を捕まえるからまず屏風から虎を追い出してくれ、みたいな話です)&lt;/p&gt;

&lt;p&gt;古文書によればこれは &lt;code&gt;document.getElementById(...)&lt;/code&gt; などで実現できますが、
今風の書き方だと &lt;code&gt;GoogleMapWebComponent&lt;/code&gt; 内の以下のような記述になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;constructor(elRef:ElementRef) {
    this.elem = elRef.nativeElement;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ルート要素が取得できるため、これをコンポーネントのプロパティに保持しておきます。&lt;/p&gt;

&lt;h2 id=&#34;子コンポーネントのプロパティに触る&#34;&gt;子コンポーネントのプロパティに触る&lt;/h2&gt;

&lt;p&gt;子コンポーネントにアクセスするには
&lt;a href=&#34;https://angular.io/docs/js/latest/api/core/ViewChild-var.html&#34;&gt;ViewChild&lt;/a&gt; などを使います。
適切に import などを行った上で、&lt;code&gt;AppComponent&lt;/code&gt; のプロパティとして以下のように宣言します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@ViewChild(GoogleMapWebComponent)
googlemap: GoogleMapWebComponent;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使えるようになるタイミングには注意が必要で、
子コンポーネントの作成が親コンポーネントよりあとに起こるため、
&lt;code&gt;ngAfterViewInit&lt;/code&gt; というメソッドが呼ばれた時点で &lt;code&gt;googlemap&lt;/code&gt; にセットされます。&lt;/p&gt;

&lt;h1 id=&#34;dom-から上がってくるイベントを捕捉する&#34;&gt;DOM から上がってくるイベントを捕捉する&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;( )&lt;/code&gt;記法でイベント名を指定し、対応する処理を右辺に書きます。
たとえば &lt;code&gt;google-map-dragend&lt;/code&gt; イベントを捕捉するには以下のように書きます。
&lt;code&gt;[dragEvents]=&amp;quot;true&amp;quot;&lt;/code&gt; はドラッグ関係のイベントを ON にするための設定です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[dragEvents]=&amp;quot;true&amp;quot; (google-map-dragend)=&amp;quot;dragendHandler($event)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはハンドラで Angular のプロパティを更新しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dragendHandler(event) {
    console.log(&#39;dragend&#39;);
    this.lat = event.target.latitude;
    this.lng = event.target.longitude;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;プロパティバインディングの捕捉&#34;&gt;プロパティバインディングの捕捉&lt;/h1&gt;

&lt;h2 id=&#34;記法の変換&#34;&gt;{{ }} 記法の変換&lt;/h2&gt;

&lt;p&gt;Angular.js に慣れていると以下のように書きたくなるかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;latitude=&amp;quot;{{lat}}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書き方でも問題なく動作します。
Angular2 は &lt;code&gt;{{ }}&lt;/code&gt; 記法を以下のように &lt;code&gt;[ ]&lt;/code&gt;記法へ変換します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[latitude]=&amp;quot;lat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは以下のようなテキストコンテンツでも同様です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt; My Name is {{ name }} &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div [textContent]=&amp;quot;&#39;My Name is &#39; + name&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;属性の削除&#34;&gt;属性の削除&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[latitude]&lt;/code&gt; や &lt;code&gt;(google-map-dragend)&lt;/code&gt; などの属性は Angular2 によって削除されるため、
ブラウザの開発コンソールで HTML を見ても載っていません。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;Angular2 から Web Components を使ってみました。
対応するコンポーネントを作って DOM 要素に触れるようにしておけば、
あとはコンポーネント間のやりとりで実現できます。&lt;/p&gt;

&lt;h1 id=&#34;参照&#34;&gt;参照&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://angular.io/docs/ts/latest/guide/template-syntax.html&#34;&gt;Angular2: Template Syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.mgechev.com/2016/01/23/angular2-viewchildren-contentchildren-difference-viewproviders&#34;&gt;ViewChildren and ContentChildren in Angular 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>静的サイトジェネレータの生成時間比較</title>
      <link>https://tmrtmhr.info/tech/static-site-generator-comparison/</link>
      <pubDate>Tue, 08 Dec 2015 15:08:00 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/static-site-generator-comparison/</guid>
      <description>&lt;p&gt;エンジニア界隈ではどうもブログを作る目的で静的サイトジェネレータというものが使われている、
と聞いたため、せっかくなので使ってみることにしました。
&lt;/p&gt;

&lt;p&gt;調べていく過程で&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;Hugo&lt;/a&gt;のサイトに
「Hugoは速いよ！」という内容の動画を見つけたり、
速度が原因で Hugo に移行したブログ記事を見かけたりして、
実行時間の伸び方が気になったのでざっくり確認してみます。&lt;/p&gt;

&lt;h1 id=&#34;対象としたジェネレータについて&#34;&gt;対象としたジェネレータについて&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.staticgen.com/&#34;&gt;StaticGen&lt;/a&gt;のスター数が多いものから選びました。
2015/11月の時点では Jekyll, GitBook, Octopress, Hexo, Hugo, Pelican の順です。&lt;/p&gt;

&lt;h1 id=&#34;測定環境&#34;&gt;測定環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;計算機&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mac OS X 10.10.5&lt;/td&gt;
&lt;td&gt;3.1 GHz デュアルコア Intel Core i7&lt;/td&gt;
&lt;td&gt;16GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;処理系のバージョン&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node.js&lt;/th&gt;
&lt;th&gt;Python&lt;/th&gt;
&lt;th&gt;Ruby&lt;/th&gt;
&lt;th&gt;Go&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5.0.0&lt;/td&gt;
&lt;td&gt;2.7.9&lt;/td&gt;
&lt;td&gt;2.2.1&lt;/td&gt;
&lt;td&gt;1.5.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;ジェネレータのバージョン&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Octopress&lt;/th&gt;
&lt;th&gt;Hexo&lt;/th&gt;
&lt;th&gt;Pelican&lt;/th&gt;
&lt;th&gt;GitBook&lt;/th&gt;
&lt;th&gt;Jekyll&lt;/th&gt;
&lt;th&gt;Hugo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3.0.11&lt;/td&gt;
&lt;td&gt;0.1.9&lt;/td&gt;
&lt;td&gt;3.6.3&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;td&gt;3.0.0&lt;/td&gt;
&lt;td&gt;v0.15-DEV&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;測定方法&#34;&gt;測定方法&lt;/h1&gt;

&lt;p&gt;以下の手順を繰り返し、5回計測して単純平均を取りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;出力先にある生成物を消しておく&lt;/li&gt;
&lt;li&gt;本文に&amp;rdquo;あ&amp;rdquo;を1000文字並べた md ファイルを必要な個数用意する

&lt;ul&gt;
&lt;li&gt;1,10,100,1000 という刻み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;各ジェネレータの実行時間を time コマンドの user + sys で測る

&lt;ul&gt;
&lt;li&gt;たとえば Hexo なら hexo generate を実行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;生成時間測定結果&#34;&gt;生成時間測定結果&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;静的サイトジェネレータの CPU 時間(秒)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;記事数&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Octopress&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Hexo&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Pelican&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Gitbook&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Jekyll&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Hugo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.39&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.43&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.02&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.98&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.96&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.44&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.37&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.03&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.94&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.79&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.55&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;25.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.61&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.34&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.82&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&#34;https://tmrtmhr.info/img/staticSiteGeneratorComparison.png&#34; alt=&#34;静的サイトジェネレータの実行時間グラフ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;確かに Hugo が速いです。
CPU 時間も短いですが、Hugo はどこかで並列処理をしているらしくマルチコアを活用できているようだったため、
実時間ではもう少し速くなるはずです。&lt;/p&gt;

&lt;h1 id=&#34;そもそも生成時間が長いと何が困るのか&#34;&gt;そもそも生成時間が長いと何が困るのか？&lt;/h1&gt;

&lt;p&gt;編集→確認のループが長くなりイライラします。
記事を保存してから LiveReload で再読み込みが完了するまでの待ち時間が苦痛になりますし、
デザインを変えようとして再生成するとか、Github Pages などへのデプロイのために再生成するとか、
CPUを温めるために再生成するとか、生活の端々でいったん待たされることになります。&lt;/p&gt;

&lt;p&gt;「Hugo に移行した」系のブログ記事でも
「元々使っていたジェネレータの遅さに耐えきれなくなった」という理由が散見されました。
生成時間の長さは移行の原因となりえます。&lt;/p&gt;

&lt;p&gt;というわけで生成時間の伸び方は静的サイトジェネレータを選ぶ際のひとつの尺度になるかと思います。&lt;/p&gt;

&lt;p&gt;とはいえ記事数が少ないうちは問題にならないですし、
生成物の違い・Github Pages などとの連携のような機能面での差異、
デザインの豊富さや情報の多さなども重要ですから、問題になってから移行を考えてもいいと思います。
そもそも別のことをやって待てばいいという向きもあるでしょうし、
耐えきれるかどうか、一度適当に記事を増やして体感してみるのがおすすめです。&lt;/p&gt;

&lt;p&gt;とりあえず自分は Hugo を使ってみます。&lt;/p&gt;

&lt;h1 id=&#34;余談&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;Octopress の時間は指数的に増えているように見えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tmrtmhr.info/img/staticSiteGeneratorComparison-5000.png&#34; alt=&#34;静的サイトジェネレータの実行時間グラフ&#34; /&gt;&lt;/p&gt;

&lt;!-- 10000 記事では Hugo のサーバが起動しませんでした。 --&gt;

&lt;!-- ``` --&gt;

&lt;!-- ERROR: 2015/11/16 Error: listen tcp 127.0.0.1:1313: socket: too many open files in system --&gt;

&lt;!-- ``` --&gt;</description>
    </item>
    
  </channel>
</rss>