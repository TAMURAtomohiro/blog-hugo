<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 嵐の小舟より</title>
    <link>https://tmrtmhr.info/tags/go/index.xml</link>
    <description>Recent content in Go on 嵐の小舟より</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <atom:link href="https://tmrtmhr.info/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go言語で union とか直和型のようなデータを表現したいときは interface を使う</title>
      <link>https://tmrtmhr.info/tech/sum-type-in-golang/</link>
      <pubDate>Wed, 29 Mar 2017 22:46:34 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/sum-type-in-golang/</guid>
      <description>&lt;p&gt;たとえば Haskell では以下のようなデータ型を定義できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data Tree = Leaf | Branch Tree Tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C言語で言えばタグ付き共用体(union)のような感じです。&lt;/p&gt;

&lt;!-- ``` --&gt;

&lt;!-- union Tree { --&gt;

&lt;!--   struct Leaf { --&gt;

&lt;!--     tag int; --&gt;

&lt;!--   } leaf; --&gt;

&lt;!--   struct Branch { --&gt;

&lt;!--     tag int; --&gt;

&lt;!--     left *Tree; --&gt;

&lt;!--     right *Tree; --&gt;

&lt;!--   } branch; --&gt;

&lt;!-- } --&gt;

&lt;!-- ``` --&gt;

&lt;p&gt;この記事は、こんな感じで木構造などを表現したい時
Go 言語ではどうするのか？という点について調べてみたメモです。
結論としては&lt;code&gt;type Tree interface{ ... }&lt;/code&gt;を定義します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;data Tree a&lt;/code&gt; のように汎用的なコンテナを作る方法については言及しません。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;leaf-と-branch-に対して行いたい操作&#34;&gt;Leaf と Branch に対して行いたい操作&lt;/h1&gt;

&lt;p&gt;ここでは&lt;code&gt;Tree&lt;/code&gt;中の&lt;code&gt;Leaf&lt;/code&gt;を数える&lt;code&gt;Count&lt;/code&gt;という関数を考えてみます。
Haskell だったらパターンマッチで分岐です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;count :: Tree -&amp;gt; Int
count Leaf = 1
count (Branch l r) = count l + count r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今Go言語で実現したいのは以下のような内容です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt;か&lt;code&gt;Branch&lt;/code&gt;のどちらかのデータ構造を引数に取る&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt;か&lt;code&gt;Branch&lt;/code&gt;かによって処理を分岐する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そこで登場するのが &lt;code&gt;interface&lt;/code&gt; です。
ここで&lt;code&gt;Leaf&lt;/code&gt;と&lt;code&gt;Branch&lt;/code&gt;は&lt;code&gt;count&lt;/code&gt;という共通のインタフェースを持っているわけなので、
そういうふうに書きます。&lt;/p&gt;

&lt;p&gt;そんなわけでコードは以下の通りです。&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/tmrtmhr/3134ee6b7201197471e33f98780e1285.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;ということでGo言語で木構造のような直和型のデータ構造を扱う小さな例を示しました。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GO言語で雛形JSONの内容をコマンド出力の内容で置換する</title>
      <link>https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/</link>
      <pubDate>Tue, 14 Mar 2017 18:04:09 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/</guid>
      <description>&lt;p&gt;AWS CLI によりコマンドラインから制御したりする際、リクエストパラメータとして JSON ファイルが必要になることがあります。
&lt;a href=&#34;https://tmrtmhr.info/tech/aws/delete-updated-file-cache-on-cloudfront/&#34;&gt;CloudFront のキャッシュを削除したいとき&lt;/a&gt;なんかがそうです。&lt;/p&gt;

&lt;p&gt;AWS CLI のコマンドごとに、リクエストJSONを生成する専用スクリプトを書くという手もありますが、
シェル上でパイプやらリダイレクトやらを駆使していい感じに JSON を生成できるある程度汎用的なスクリプトにならんものか、
という思いから試してみた結果をここに記します。
どこかに既にあるものでしたらすみません。&lt;/p&gt;

&lt;p&gt;コマンド引数は以下のようになっていて、JSON ファイルは標準入力から与えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;filljson ${入力の型} ${キーパス} ${入力ファイル名}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;標準入出力で JSON をやりとりするので以下のようにパイプでつなげることで
中間ファイルを作ることなく最終的なリクエスト JSON が得られます。
入力ファイル名のところには &lt;code&gt;bash&lt;/code&gt; や &lt;code&gt;zsh&lt;/code&gt; のプロセス置換機能を利用しています。
プロセス置換機能を使うとプログラム側からは単にファイルパスが渡ってくるように見えるので、
ファイルIOとして処理すればOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat json/cloudfront-invalidation.json |
  filljson int InvalidationBatch.Paths.Quantity &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | wc -l) |
  filljson [string] InvalidationBatch.Paths.Items &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | sed -e &#39;s/^public//g&#39;) |
  filljson string InvalidationBatch.CallerReference &amp;lt;(date +&amp;quot;osone3-%Y/%m/%d-%H:%k:%m&amp;quot; | tr -d &#39;\n&#39;) |
  jq . &amp;gt; request.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;プログラムの内容&#34;&gt;プログラムの内容&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tmrtmhr/filljson&#34;&gt;コードはここ&lt;/a&gt;で、
Go 言語で書いたので &lt;code&gt;go get github.com/tmrtmhr/filljson&lt;/code&gt; でコマンドをインストールできます。
リポジトリの &lt;code&gt;js/filljson.js&lt;/code&gt; に node.js で実装したものもあります。&lt;/p&gt;

&lt;p&gt;どこかでエラーが出たら死にます(&lt;code&gt;os.Exit(1)&lt;/code&gt;)。
テストコードは少しだけ書きました。&lt;/p&gt;

&lt;p&gt;入力としては配列を想定しておらず、オブジェクトのみなので &lt;code&gt;map[string]interface{}&lt;/code&gt; 型を &lt;code&gt;json.Unmarshal&lt;/code&gt; に渡します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var jsonData map[string]interface{}
err = json.Unmarshal(jsonStr, &amp;amp;jsonData)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取り出した値が &lt;code&gt;interface{}&lt;/code&gt; となっているので再度 &lt;code&gt;map[string]interface{}&lt;/code&gt;として型アサーションをつけます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;finger = finger[propName].(map[string]interface{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.kaoriya.net/blog/2016/06/25/&#34;&gt;golang は ゆるふわに JSON を扱えまぁす!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;雑感&#34;&gt;雑感&lt;/h1&gt;

&lt;p&gt;標準入出力は偉大です。&lt;/p&gt;

&lt;p&gt;GO言語的には特化した(たとえばCloudFront専用のJSON生成専用)コマンドを作ってきっちり型検査したほうが良さそうですが、
まあこういう書き方もできるということで御参考いただければ幸いです。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>