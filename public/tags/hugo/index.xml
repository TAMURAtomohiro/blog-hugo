<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hugo on 嵐の小舟より</title>
    <link>https://tmrtmhr.info/tags/hugo/index.xml</link>
    <description>Recent content in Hugo on 嵐の小舟より</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <atom:link href="https://tmrtmhr.info/tags/hugo/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>git diff を利用して更新のあったファイルのみ CloudFront のキャッシュを削除する</title>
      <link>https://tmrtmhr.info/tech/aws/delete-updated-file-cache-on-cloudfront/</link>
      <pubDate>Tue, 14 Mar 2017 17:15:21 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/aws/delete-updated-file-cache-on-cloudfront/</guid>
      <description>&lt;p&gt;本サイトは Hugo で生成したものを GitHub Pages に push して公開し、
CloudFront を利用して配信しています。
CloudFront はキャッシュサーバとして働くので、
何もしなければ TTL が切れるまでは古いコンテンツが表示されます。&lt;/p&gt;

&lt;p&gt;単純にキャッシュ全削除という手もありますが、
せっかくなので更新のあったファイルのみキャッシュを削除してみました。&lt;/p&gt;

&lt;p&gt;やっていることは以下のような感じです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git diff&lt;/code&gt; で更新のあったファイル一覧を取得&lt;/li&gt;
&lt;li&gt;一覧を加工して AWS CLI 用の JSON ファイルを生成&lt;/li&gt;
&lt;li&gt;AWS CLI の &lt;code&gt;aws cloudfront create-invalidation&lt;/code&gt; でキャッシュ削除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;前提-ブログデータを管理するリポジトリの構成&#34;&gt;前提：ブログデータを管理するリポジトリの構成&lt;/h1&gt;

&lt;p&gt;本サイトの構成では以下の二種類のリポジトリが登場します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Markdown などを管理するリポジトリ(&lt;code&gt;blog-hugo&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;生成したHTMLを GitHub Pages で公開するリポジトリ(&lt;code&gt;tmrtmhr.github.io&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;blog-hugo/public&lt;/code&gt; に &lt;code&gt;tmrtmhr.github.io&lt;/code&gt; を &lt;code&gt;subtree&lt;/code&gt; として取り込んでいます。&lt;/p&gt;

&lt;p&gt;この構成は、昔&lt;a href=&#34;http://gohugo.io/tutorials/github-pages-blog/#hosting-personal-organization-pages&#34;&gt;「Hugo チュートリアル：GitHub Pages で個人ページを公開する」&lt;/a&gt;
を参考にして言われるがままに構成したのですが、
現在は &lt;code&gt;submodule&lt;/code&gt; として取り込んで、&lt;code&gt;public&lt;/code&gt; 以下のみ &lt;code&gt;push&lt;/code&gt; するようになっており、
Markdown のほうの管理には言及がなくなったようです。&lt;/p&gt;

&lt;h1 id=&#34;更新のあったファイル一覧の取得&#34;&gt;更新のあったファイル一覧の取得&lt;/h1&gt;

&lt;p&gt;Hugo で生成した HTML ファイル群は &lt;code&gt;public&lt;/code&gt; ディレクトリ以下に出来上がりますが、
全記事を再生成するのでタイムスタンプがほぼ同じとなります。
なので、&lt;code&gt;find public -mmin -5&lt;/code&gt;のようにして5分以内に更新のあったファイルを探して……というアプローチではうまくいきません。&lt;/p&gt;

&lt;p&gt;というわけで &lt;code&gt;git diff&lt;/code&gt; を使います。
&lt;code&gt;--diff-filter=M&lt;/code&gt; で更新のあったファイルのみの抽出、&lt;code&gt;--name-only&lt;/code&gt;でパスのみの表示、&lt;code&gt;HEAD^ HEAD&lt;/code&gt; で一つ前と最新との比較、&lt;code&gt;public&lt;/code&gt; で対象のディレクトリを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git diff --diff-filter=M --name-only HEAD^ HEAD public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://qiita.com/kaminaly/items/28f9cb4e680deb700833&#34;&gt;gitで差分ファイルを抽出する&lt;/a&gt;、&lt;a href=&#34;https://git-scm.com/docs/git-diff&#34;&gt;git diff のオプション&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ファイル一覧を-json-ファイルへ加工&#34;&gt;ファイル一覧を JSON ファイルへ加工&lt;/h1&gt;

&lt;p&gt;AWS CLI で CloudFront にキャッシュ削除したいファイルパスを送る際、
コマンド引数として &lt;code&gt;--paths&lt;/code&gt; も利用できますが、
ファイル数が増えてくると&lt;a href=&#34;https://www.ecoop.net/memo/archives/2010-01-26-1.html&#34;&gt;コマンド引数の長さ制限&lt;/a&gt;に引っかかりそうなので、
JSON を構築することにします。&lt;/p&gt;

&lt;p&gt;AWS CLI から CloudFront にキャッシュ削除リクエストを投げるための雛形JSONが以下のコマンドで得られます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aws cloudfront create-invalidation --generate-cli-skeleton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注： AWS CLI のバージョン &lt;code&gt;aws-cli/1.11.58&lt;/code&gt; においても &lt;code&gt;cloudfront&lt;/code&gt; コマンドはプレビュー版なので
&lt;code&gt;aws configure set preview.cloudfront true&lt;/code&gt; とコマンドを打って設定ファイルを書き換えてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;DistributionId&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;InvalidationBatch&amp;quot;: {
        &amp;quot;Paths&amp;quot;: {
            &amp;quot;Quantity&amp;quot;: 0,
            &amp;quot;Items&amp;quot;: [
                &amp;quot;&amp;quot;
            ]
        },
        &amp;quot;CallerReference&amp;quot;: &amp;quot;&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DistributionId&lt;/code&gt;: 対象とする CloudFront ディストリビューションID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Items&lt;/code&gt;: ファイルパスのリスト&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Quantity&lt;/code&gt;: ファイルパスの数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CallerReference&lt;/code&gt;: こちらで自由に指定するリクエストのID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;CallerReference&lt;/code&gt; は、&lt;a href=&#34;http://docs.aws.amazon.com/cli/latest/reference/cloudfront/create-invalidation.html&#34;&gt;AWS CLI のリファレンス&lt;/a&gt;によると
「間違って同じリクエストが重複しないよう」に使われます。
まったく同じリクエストを投げた場合は新しい Invalidation Batch は作られず、
&lt;code&gt;CallerReference&lt;/code&gt;が重複していて &lt;code&gt;Items&lt;/code&gt; の内容が異なるような場合は &lt;code&gt;InvalidationBatchAlreadyExists&lt;/code&gt; となるようです。
とりあえず時刻に基いて生成すれば良いかと思います。&lt;/p&gt;

&lt;p&gt;この雛形JSONに対しコマンド出力をはめこんでリクエストを作ります。
&lt;a href=&#34;https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/&#34;&gt;この加工のためのスクリプト&lt;/a&gt;は別記事にしていますので
詳細についてはそちらをご参照ください。&lt;/p&gt;

&lt;p&gt;こういったスクリプトがあると、以下のようにして、雛形となるJSONにコマンドの出力を当てはめていって最終的なリクエストJSONを得られます。
(&lt;code&gt;DistributionId&lt;/code&gt; についてはあらかじめ JSON に書いてあります)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat json/cloudfront-invalidation.json |
  filljson int InvalidationBatch.Paths.Quantity &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | wc -l) |
  filljson [string] InvalidationBatch.Paths.Items &amp;lt;(git diff --ignore-all-space --diff-filter=M --name-only HEAD^ HEAD  public | sed -e &#39;s/^public//g&#39;) |
  filljson string InvalidationBatch.CallerReference &amp;lt;(date +&amp;quot;tmrtmhr-%Y/%m/%d-%H:%k:%m&amp;quot; | tr -d &#39;\n&#39;) |
  jq . &amp;gt; request.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;aws-cli-を使用した-cloudfront-のキャッシュ削除&#34;&gt;AWS CLI を使用した CloudFront のキャッシュ削除&lt;/h1&gt;

&lt;p&gt;前項でリクエストJSONを生成したので、それを投げます。
使用する profile については適宜指定してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aws cloudfront create-invalidation --cli-input-json file://request.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;invalidation-の注意点&#34;&gt;Invalidation の注意点&lt;/h1&gt;

&lt;p&gt;月間 1000 ファイルパスまでは無料、以降は $0.005 / 1パスとなるようなので、
更新が頻繁にある・更新ファイル数が多いなどで Invaliation を乱発するケースでは追加で料金が発生します。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://dev.sukimash.com/aws/cloud-front-invalidation/&#34;&gt;CLOUD FRONT の INVALIDATION が有料だなんて知らんかった&lt;/a&gt;、&lt;a href=&#34;https://aws.amazon.com/jp/cloudfront/pricing/&#34;&gt;CloudFront: 料金&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; の結果から CloudFront のキャッシュ削除を行う例を示しました。
リクエストのための JSON 生成については&lt;a href=&#34;https://tmrtmhr.info/tech/replace-a-part-of-json-with-command-output/&#34;&gt;補助スクリプト&lt;/a&gt;を作って公開しています。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hugo でマテリアルアイコンを使うための ShortCode</title>
      <link>https://tmrtmhr.info/tech/hugo-with-material-icon/</link>
      <pubDate>Wed, 08 Mar 2017 08:52:50 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/hugo-with-material-icon/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; で任意の HTML を生成したい場合は &lt;a href=&#34;https://gohugo.io/extras/shortcodes/&#34;&gt;ShortCode&lt;/a&gt; を書くことになります。&lt;/p&gt;

&lt;p&gt;本サイトでは使い道はさておきマテリアルアイコンを読み込んでいるので、
ShortCode で使えるようにしてみました。
&lt;/p&gt;

&lt;h1 id=&#34;hugo-からマテリアルアイコンを使う手順&#34;&gt;Hugo からマテリアルアイコンを使う手順&lt;/h1&gt;

&lt;p&gt;まず &lt;code&gt;themes/${テーマ名}/layouts/partials/header.html&lt;/code&gt; などに以下を追記してマテリアルアイコンのフォントを読み込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://fonts.googleapis.com/icon?family=Material+Icons&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;layouts/shortcodes/md-icon.html&lt;/code&gt; として以下の内容を用意し、ShortCode として使えるようにします。&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/tmrtmhr/90cff33e3e18fbc10f8daf9dac753b30.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;ここで、&lt;code&gt;vertical-align: bottom;&lt;/code&gt; はアイコンと文章の高さをそろえるための指定です。
また、&lt;code&gt;.Get 0&lt;/code&gt; で ShortCode の引数を取得しています。&lt;/p&gt;

&lt;p&gt;Markdown ファイル中では以下のように書きます。これにより &lt;code&gt;favorite&lt;/code&gt; が &lt;code&gt;.Get 0&lt;/code&gt; の部分に埋め込まれた HTML を生成します。&lt;/p&gt;

&lt;p&gt;{{&amp;lt; md-icon favorite &amp;gt;}}&lt;/p&gt;

&lt;p&gt;&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;

表示はこんな感じです
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;i class=&#34;material-icons castaway-md-icon&#34;&gt;
  favorite
&lt;/i&gt;
&lt;/p&gt;

&lt;h1 id=&#34;なぜ-raw-html-ではなく-shortcode-を書くのか&#34;&gt;なぜ Raw HTML ではなく ShortCode を書くのか&lt;/h1&gt;

&lt;p&gt;Markdown は &lt;a href=&#34;http://daringfireball.net/projects/markdown/syntax#html&#34;&gt;HTMLを埋め込める&lt;/a&gt;ため、
アイコン表示の HTML (前述の Gist)を直接書いても表示されます。&lt;/p&gt;

&lt;p&gt;ではなぜ ShortCode として用意するのかというと、
&lt;a href=&#34;https://gohugo.io/extras/shortcodes/&#34;&gt;公式サイトの説明&lt;/a&gt;にある通り、
以下のような利点があるためです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定型のHTMLを毎回書かずにすむ&lt;/li&gt;
&lt;li&gt;ShortCode を変更することで該当の HTML 部分がすべて置き換わるので更新が楽にすむ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そんなわけで、一生に一度の HTML だと心に決めている、というのでなければ、
ShortCode 化して再利用するほうが良いかと思います。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>静的サイトジェネレータの生成時間比較</title>
      <link>https://tmrtmhr.info/tech/static-site-generator-comparison/</link>
      <pubDate>Tue, 08 Dec 2015 15:08:00 +0900</pubDate>
      
      <guid>https://tmrtmhr.info/tech/static-site-generator-comparison/</guid>
      <description>&lt;p&gt;エンジニア界隈ではどうもブログを作る目的で静的サイトジェネレータというものが使われている、
と聞いたため、せっかくなので使ってみることにしました。
&lt;/p&gt;

&lt;p&gt;調べていく過程で&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;Hugo&lt;/a&gt;のサイトに
「Hugoは速いよ！」という内容の動画を見つけたり、
速度が原因で Hugo に移行したブログ記事を見かけたりして、
実行時間の伸び方が気になったのでざっくり確認してみます。&lt;/p&gt;

&lt;h1 id=&#34;対象としたジェネレータについて&#34;&gt;対象としたジェネレータについて&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.staticgen.com/&#34;&gt;StaticGen&lt;/a&gt;のスター数が多いものから選びました。
2015/11月の時点では Jekyll, GitBook, Octopress, Hexo, Hugo, Pelican の順です。&lt;/p&gt;

&lt;h1 id=&#34;測定環境&#34;&gt;測定環境&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;計算機&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mac OS X 10.10.5&lt;/td&gt;
&lt;td&gt;3.1 GHz デュアルコア Intel Core i7&lt;/td&gt;
&lt;td&gt;16GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;処理系のバージョン&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node.js&lt;/th&gt;
&lt;th&gt;Python&lt;/th&gt;
&lt;th&gt;Ruby&lt;/th&gt;
&lt;th&gt;Go&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5.0.0&lt;/td&gt;
&lt;td&gt;2.7.9&lt;/td&gt;
&lt;td&gt;2.2.1&lt;/td&gt;
&lt;td&gt;1.5.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;ジェネレータのバージョン&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Octopress&lt;/th&gt;
&lt;th&gt;Hexo&lt;/th&gt;
&lt;th&gt;Pelican&lt;/th&gt;
&lt;th&gt;GitBook&lt;/th&gt;
&lt;th&gt;Jekyll&lt;/th&gt;
&lt;th&gt;Hugo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;3.0.11&lt;/td&gt;
&lt;td&gt;0.1.9&lt;/td&gt;
&lt;td&gt;3.6.3&lt;/td&gt;
&lt;td&gt;1.0.0&lt;/td&gt;
&lt;td&gt;3.0.0&lt;/td&gt;
&lt;td&gt;v0.15-DEV&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;測定方法&#34;&gt;測定方法&lt;/h1&gt;

&lt;p&gt;以下の手順を繰り返し、5回計測して単純平均を取りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;出力先にある生成物を消しておく&lt;/li&gt;
&lt;li&gt;本文に&amp;rdquo;あ&amp;rdquo;を1000文字並べた md ファイルを必要な個数用意する

&lt;ul&gt;
&lt;li&gt;1,10,100,1000 という刻み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;各ジェネレータの実行時間を time コマンドの user + sys で測る

&lt;ul&gt;
&lt;li&gt;たとえば Hexo なら hexo generate を実行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;生成時間測定結果&#34;&gt;生成時間測定結果&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;静的サイトジェネレータの CPU 時間(秒)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;記事数&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Octopress&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Hexo&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Pelican&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Gitbook&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Jekyll&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Hugo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.39&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.43&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.02&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.98&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.96&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.44&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.64&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.37&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.03&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.94&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.22&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.79&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.55&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;25.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.61&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.34&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.82&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&#34;https://tmrtmhr.info/img/staticSiteGeneratorComparison.png&#34; alt=&#34;静的サイトジェネレータの実行時間グラフ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;確かに Hugo が速いです。
CPU 時間も短いですが、Hugo はどこかで並列処理をしているらしくマルチコアを活用できているようだったため、
実時間ではもう少し速くなるはずです。&lt;/p&gt;

&lt;h1 id=&#34;そもそも生成時間が長いと何が困るのか&#34;&gt;そもそも生成時間が長いと何が困るのか？&lt;/h1&gt;

&lt;p&gt;編集→確認のループが長くなりイライラします。
記事を保存してから LiveReload で再読み込みが完了するまでの待ち時間が苦痛になりますし、
デザインを変えようとして再生成するとか、Github Pages などへのデプロイのために再生成するとか、
CPUを温めるために再生成するとか、生活の端々でいったん待たされることになります。&lt;/p&gt;

&lt;p&gt;「Hugo に移行した」系のブログ記事でも
「元々使っていたジェネレータの遅さに耐えきれなくなった」という理由が散見されました。
生成時間の長さは移行の原因となりえます。&lt;/p&gt;

&lt;p&gt;というわけで生成時間の伸び方は静的サイトジェネレータを選ぶ際のひとつの尺度になるかと思います。&lt;/p&gt;

&lt;p&gt;とはいえ記事数が少ないうちは問題にならないですし、
生成物の違い・Github Pages などとの連携のような機能面での差異、
デザインの豊富さや情報の多さなども重要ですから、問題になってから移行を考えてもいいと思います。
そもそも別のことをやって待てばいいという向きもあるでしょうし、
耐えきれるかどうか、一度適当に記事を増やして体感してみるのがおすすめです。&lt;/p&gt;

&lt;p&gt;とりあえず自分は Hugo を使ってみます。&lt;/p&gt;

&lt;h1 id=&#34;余談&#34;&gt;余談&lt;/h1&gt;

&lt;p&gt;Octopress の時間は指数的に増えているように見えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tmrtmhr.info/img/staticSiteGeneratorComparison-5000.png&#34; alt=&#34;静的サイトジェネレータの実行時間グラフ&#34; /&gt;&lt;/p&gt;

&lt;!-- 10000 記事では Hugo のサーバが起動しませんでした。 --&gt;

&lt;!-- ``` --&gt;

&lt;!-- ERROR: 2015/11/16 Error: listen tcp 127.0.0.1:1313: socket: too many open files in system --&gt;

&lt;!-- ``` --&gt;</description>
    </item>
    
  </channel>
</rss>